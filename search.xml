<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo配置</title>
      <link href="/2019/09/21/hexo%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/09/21/hexo%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hexo搭建博客有用的一些配置"><a href="#1-Hexo搭建博客有用的一些配置" class="headerlink" title="1. Hexo搭建博客有用的一些配置"></a>1. Hexo搭建博客有用的一些配置</h1><h2 id="1-1-统计字数和时间"><a href="#1-1-统计字数和时间" class="headerlink" title="1.1. 统计字数和时间"></a>1.1. 统计字数和时间</h2><ul><li><p>安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure></li><li><p>安装完后在_config.yml中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false #这行不能少</span><br></pre></td></tr></table></figure></li><li><p>在NexT的config中进一步配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 2</span><br><span class="line">  wpm: 300</span><br><span class="line">  suffix: mins.</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>如果出现阅读字数undefined或者阅读时间NaN的情形，可以先clean然后再生成，还不行可以重启一下试试</p><ul><li>参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">awl – Average Word Length (chars count in word). Default: 4. You can check this here.</span><br><span class="line">CN ≈ 2</span><br><span class="line">EN ≈ 5</span><br><span class="line">RU ≈ 6</span><br><span class="line">wpm – Words Per Minute. Default: 275. You can check this here.</span><br><span class="line">Slow ≈ 200</span><br><span class="line">Normal ≈ 275</span><br><span class="line">Fast ≈ 350</span><br><span class="line">suffix – If time to read less then 60 minutes, added suffix as string parameter.</span><br><span class="line">If not defined, mins. will be used as default.</span><br><span class="line">exclude_codeblock – Allow to exclude all content inside code blocks for more accurate words counting.</span><br><span class="line">If not defined, false will be used as default.</span><br><span class="line">Note for Chinese users: because in Chinese language average word length about ~1.5 and if you at most cases write posts in Chinese (without mixed English), recommended to set awl to 2 and wpm to 300.</span><br><span class="line">But if you usualy mix your posts with English, awl to 4 and wpm to 275 will be nice.</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-添加站内搜索"><a href="#1-2-添加站内搜索" class="headerlink" title="1.2. 添加站内搜索"></a>1.2. 添加站内搜索</h2><ul><li>安装插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装完后在_config.yml中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 站内搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li><li><p>在NexT的config中进一步配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/wzpan/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false.</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-添加热度"><a href="#1-2-添加热度" class="headerlink" title="1.2. 添加热度"></a>1.2. 添加热度</h2><ul><li><a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a>注册<br>注册完后创建应用，然后在存储中新建class，class的名称必须为Counter</li><li>在设置中的安全中心设置安全域名</li><li><p>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-leancloud-counter-security --save</span><br></pre></td></tr></table></figure></li><li><p>安装完后在_config.yml中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leancloud_counter_security:</span><br><span class="line">  enable_sync: true</span><br><span class="line">  app_id: &lt;&lt;your app id&gt;&gt;</span><br><span class="line">  app_key: &lt;&lt;your app key&gt;</span><br><span class="line">  username: </span><br><span class="line">  password:</span><br></pre></td></tr></table></figure></li></ul><p>其中采用<code>hexo lc-counter r &lt;&lt;username&gt;&gt; &lt;&lt;password&gt;&gt;</code>命令注册用户（<font color="red" face="黑体">注意：密码不包括感叹号之类的</font>），用户和密码可以选择配置到对应位置，如果不配置，每次部署记得输入用户名或者密码就好。</p><ul><li><p>NexT的config中配置<br>到LendCloud应用class设置里面复制id和key，拷贝到对应位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn to get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: # &lt;app_id&gt;</span><br><span class="line">  app_key: # &lt;app_key&gt;</span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: true</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></li><li><p>页面LeanCloud访问统计提示’Counter not initialized! See more at console err msg.’<br>可以按照该文进行修复<br><a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener"><font color="red" face="黑体">NexT主题使用的Leancloud访客统计插件存在重大安全漏洞</font></a></p></li><li>多个部署<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repository: git@github.com:SXong/SXong.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">- type: leancloud_counter_security_sync</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown用法</title>
      <link href="/2019/09/20/markdown%E7%94%A8%E6%B3%95/"/>
      <url>/2019/09/20/markdown%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Markdown有用的小技巧"><a href="#1-Markdown有用的小技巧" class="headerlink" title="1. Markdown有用的小技巧"></a>1. Markdown有用的小技巧</h1><h2 id="1-1-多级目录与列表"><a href="#1-1-多级目录与列表" class="headerlink" title="1.1. 多级目录与列表"></a>1.1. 多级目录与列表</h2><ul><li>安装 vscode</li><li>安装插件 Markdown TOC(有自动生成目录和标题序号的功能)</li></ul><h2 id="1-2-链接"><a href="#1-2-链接" class="headerlink" title="1.2. 链接"></a>1.2. 链接</h2><p> 文字超链接：<code>[文字](网址)</code></p><h2 id="1-2-更改字体、字号和颜色"><a href="#1-2-更改字体、字号和颜色" class="headerlink" title="1.2. 更改字体、字号和颜色"></a>1.2. 更改字体、字号和颜色</h2><ul><li><p>更改颜色方式1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=red&gt;建议下载tar.gz文件，bz2文件可能构建Jamfile，解压缩时注意解压完全&lt;/font&gt;</span><br></pre></td></tr></table></figure></li><li><p>更改颜色方式2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;color:red;&quot;&gt;***建议下载tar.gz文件，bz2文件可能构建Jamfile，解压缩时注意解压完全***&lt;/span&gt;</span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;</span><br><span class="line">&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;</span><br><span class="line">&lt;font color=gray size=72&gt;color=gray&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boost::format使用</title>
      <link href="/2019/09/20/boost-format%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/20/boost-format%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-boost安装"><a href="#1-boost安装" class="headerlink" title="1. boost安装"></a>1. boost安装</h1><h2 id="1-1-yum安装"><a href="#1-1-yum安装" class="headerlink" title="1.1. yum安装"></a>1.1. yum安装</h2><p>进入root帐户，运行以下三行命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install boost</span><br><span class="line">yum install boost-devel</span><br><span class="line">yum install boost-doc</span><br></pre></td></tr></table></figure></p><p>安装完毕后，可以在usr/include里面找到头文件，cmake配置好后一直没找到库文件，Boost_LIBRARIES的值一直为空，值为空的原因是我只是<code>find_package(Boost)</code>，没有指定组件，指定了还报错的话，个人猜测可能是上面几行命令还不够，因为<code>yum list | grep boost</code>后除了以上三个安装包外，还有很多库文件的包，如<code>boost-filesystem.i686</code>,虽然可以通过<code>yum install boost*</code>暴力安装，但也不清楚有没有缺东西，所以采用压缩包安装的方式。如果只是用一些包的话，也可以用yum把需要的包装上。</p><a id="more"></a><h2 id="1-2-压缩包安装"><a href="#1-2-压缩包安装" class="headerlink" title="1.2. 压缩包安装"></a>1.2. 压缩包安装</h2><h3 id="1-2-1-官网下载boost"><a href="#1-2-1-官网下载boost" class="headerlink" title="1.2.1. 官网下载boost"></a>1.2.1. 官网下载boost</h3><p>下载<a href="https://www.boost.org/" target="_blank" rel="noopener">boost</a>，下载完成后解压，并进入解压缩后的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar --bzip2 -xf boost_1_57_0.tar.bz2</span><br><span class="line">cd boost_1_57_0</span><br></pre></td></tr></table></figure></p><p><span style="color:red;"><strong><em>建议下载tar.gz文件，bz2文件可能构建Jamfile，解压缩时注意解压完全</em></strong></span></p><h3 id="1-2-2-编译安装boost"><a href="#1-2-2-编译安装boost" class="headerlink" title="1.2.2. 编译安装boost"></a>1.2.2. 编译安装boost</h3><p>打开目录下的index.html网页，进入Getting_started，在右下角点击<code>Getting started on Unix variants(e.g.Linux, MacOS)</code> ，然后按照官方给的帮助进行安装。简单编译安装如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh --prefix=path/to/installation/prefix</span><br><span class="line">./b2 install</span><br></pre></td></tr></table></figure></p><p>如果安装后想马上使用boost库进行编译，还需要执行一下这个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure></p><p>更新一下系统的动态链接库</p><h3 id="1-2-3"><a href="#1-2-3" class="headerlink" title="1.2.3."></a>1.2.3.</h3><h1 id="2-Linux下cmake编译时链接boost库"><a href="#2-Linux下cmake编译时链接boost库" class="headerlink" title="2. Linux下cmake编译时链接boost库"></a>2. Linux下cmake编译时链接boost库</h1><h2 id="2-1-find-package"><a href="#2-1-find-package" class="headerlink" title="2.1. find_package"></a>2.1. find_package</h2><p>find_package是CMake打包配置文件的工具。Find Boost包括目录和库<br>通过以下形式调用find_package来使用此模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(Boost</span><br><span class="line">  [version] [EXACT]      # Minimum or EXACT version e.g. 1.36.0</span><br><span class="line">  [REQUIRED]             # Fail with error if Boost is not found</span><br><span class="line">  [COMPONENTS &lt;libs&gt;...] # Boost libraries by their canonical name</span><br><span class="line">  )                      # e.g. &quot;date_time&quot; for &quot;libboost_date_time&quot;</span><br></pre></td></tr></table></figure></p><p><strong><em>find_package必须小写，以下变量名注意大小写</em></strong><br>在上述命令成功运行完后，可以得到保存路径等信息的变量，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Boost_FOUND            - True if headers and requested libraries were found</span><br><span class="line">Boost_INCLUDE_DIRS     - Boost include directories</span><br><span class="line">Boost_LIBRARY_DIRS     - Link directories for Boost libraries</span><br><span class="line">Boost_LIBRARIES        - Boost component libraries to be linked</span><br><span class="line">Boost_&lt;C&gt;_FOUND        - True if component &lt;C&gt; was found (&lt;C&gt; is upper-case)</span><br><span class="line">Boost_&lt;C&gt;_LIBRARY      - Libraries to link for component &lt;C&gt; (may include</span><br><span class="line">                         target_link_libraries debug/optimized keywords)</span><br><span class="line">Boost_VERSION          - BOOST_VERSION value from boost/version.hpp</span><br><span class="line">Boost_LIB_VERSION      - Version string appended to library filenames</span><br><span class="line">Boost_MAJOR_VERSION    - Boost major version number (X in X.y.z)</span><br><span class="line">Boost_MINOR_VERSION    - Boost minor version number (Y in x.Y.z)</span><br><span class="line">Boost_SUBMINOR_VERSION - Boost subminor version number (Z in x.y.Z)</span><br><span class="line">Boost_LIB_DIAGNOSTIC_DEFINITIONS (Windows)</span><br><span class="line">                       - Pass to add_definitions() to have diagnostic</span><br><span class="line">                         information about Boost&apos;s automatic linking</span><br><span class="line">                         displayed during compilation</span><br></pre></td></tr></table></figure></p><p>在搜索package前，可以设置变量辅助搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOST_ROOT             - Preferred installation prefix</span><br><span class="line"> (or BOOSTROOT)</span><br><span class="line">BOOST_INCLUDEDIR       - Preferred include directory e.g. &lt;prefix&gt;/include</span><br><span class="line">BOOST_LIBRARYDIR       - Preferred library directory e.g. &lt;prefix&gt;/lib</span><br><span class="line">Boost_NO_SYSTEM_PATHS  - Set to ON to disable searching in locations not</span><br><span class="line">                         specified by these hint variables. Default is OFF.</span><br><span class="line">Boost_ADDITIONAL_VERSIONS</span><br><span class="line">                       - List of Boost versions not known to this module</span><br><span class="line">                         (Boost install locations may contain the version)</span><br></pre></td></tr></table></figure></p><p>将搜索结果永久保存在CMake缓存条目中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boost_INCLUDE_DIR         - Directory containing Boost headers</span><br><span class="line">Boost_LIBRARY_DIR         - Directory containing Boost libraries</span><br><span class="line">Boost_&lt;C&gt;_LIBRARY_DEBUG   - Component &lt;C&gt; library debug variant</span><br><span class="line">Boost_&lt;C&gt;_LIBRARY_RELEASE - Component &lt;C&gt; library release variant</span><br></pre></td></tr></table></figure></p><p>仅查找Boost头文件的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(Boost 1.36.0)</span><br><span class="line">if(Boost_FOUND)</span><br><span class="line">  include_directories($&#123;Boost_INCLUDE_DIRS&#125;)</span><br><span class="line">  add_executable(foo foo.cc)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p><p>查找Boost头文件和一些静态库的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set(Boost_USE_STATIC_LIBS        ON) # only find static libs</span><br><span class="line">set(Boost_USE_MULTITHREADED      ON)</span><br><span class="line">set(Boost_USE_STATIC_RUNTIME    OFF)</span><br><span class="line">find_package(Boost 1.36.0 COMPONENTS date_time filesystem system ...)</span><br><span class="line">if(Boost_FOUND)</span><br><span class="line">  include_directories($&#123;Boost_INCLUDE_DIRS&#125;)</span><br><span class="line">  add_executable(foo foo.cc)</span><br><span class="line">  target_link_libraries(foo $&#123;Boost_LIBRARIES&#125;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p><p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line">PROJECT(WritePts)</span><br><span class="line">SET(WritePtsSource </span><br><span class="line">       ./source/WritePts.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">set(BOOST_ROOT /usr/local)</span><br><span class="line">find_package(Boost 1.57.0 COMPONENTS regex filesystem)</span><br><span class="line">#find_package(Boost)</span><br><span class="line"></span><br><span class="line">if(Boost_FOUND)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;Boost_INCLUDE_DIRS&#125;)</span><br><span class="line">MESSAGE( STATUS &quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;)</span><br><span class="line">MESSAGE( STATUS &quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;)</span><br><span class="line">MESSAGE( STATUS &quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;)</span><br><span class="line"></span><br><span class="line">ADD_EXECUTABLE(WritePts $&#123;WritePtsSource&#125;)</span><br><span class="line">TARGET_LINK_LIBRARIES(WritePts $&#123;Boost_LIBRARIES&#125;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p><p><span style="color:red;"><strong><em>注意文件中各个变量的大小写，如果这样设置后，还存在报错，第一步先核实一下各个变量名，如果没有问题，再根据报错信息确定可能出现的原因</em></strong></span></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># CMakeLists.txt</span><br><span class="line">project(tutorial-0)</span><br><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">set(BOOST_ROOT /usr/local/install/boost_1_61_0)</span><br><span class="line"></span><br><span class="line">find_package(Boost COMPONENTS regex system REQUIRED)</span><br><span class="line"></span><br><span class="line">if(Boost_FOUND)</span><br><span class="line">    include_directories($&#123;Boost_INCLUDE_DIRS&#125;)</span><br><span class="line">    </span><br><span class="line">    MESSAGE( STATUS &quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;)</span><br><span class="line">    MESSAGE( STATUS &quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;)</span><br><span class="line">    MESSAGE( STATUS &quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;)</span><br><span class="line"></span><br><span class="line">    add_executable(foo foo.cpp)</span><br><span class="line">    target_link_libraries (foo $&#123;Boost_LIBRARIES&#125;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p><p>通过设置BOOST_ROOT来设置首选的搜索路径<br>通过MESSAGE函数把查找的结果都打印了出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- Boost_INCLUDE_DIRS = /usr/local/install/boost_1_61_0/include.</span><br><span class="line">-- Boost_LIBRARIES = /usr/local/install/boost_1_61_0/lib/libboost_regex.so;/usr/local/install/boost_1_61_0/lib/libboost_system.so.</span><br><span class="line">-- Boost_LIB_VERSION = 1_61.</span><br></pre></td></tr></table></figure></p><p>编译过程需要用到的头文件搜索路径保存在变量Boost_INCLUDE_DIRS中，所需要link的库文件路径保存在变量Boost_LIBRARIES中</p><p>参考链接<a href="https://cmake.org/cmake/help/v3.0/module/FindBoost.html" target="_blank" rel="noopener">FindBoost</a> </p><h1 id="3-boost-format使用"><a href="#3-boost-format使用" class="headerlink" title="3. boost::format使用"></a>3. boost::format使用</h1><p>安装好boost，配置好cmake之后，引入头文件format.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;boost/format.hpp&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>*.dll缺失</title>
      <link href="/2019/02/25/dll%E7%BC%BA%E5%A4%B1/"/>
      <url>/2019/02/25/dll%E7%BC%BA%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<p>因为安装的intel fortran或是vs的版本的差异，其他主机上编译的程序在另外的电脑运行时，常常会出现这种问题。此外，自己电脑安装多个版本软件时，也会时环境变量里的dll不是自己程序依赖的动态库，此时可以尝试找到自己程序依赖的动态库，将dll文件拷贝到程序路径下。<br>fortran可参考路经：<code>C:\Program File(x86)\Common Files\Intel\Shared Libraries\redist\intel64\compiler</code><br><strong> 注意64位还是32位 </strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fortran </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFM与质量流量</title>
      <link href="/2019/02/25/CFM%E4%B8%8E%E8%B4%A8%E9%87%8F%E6%B5%81%E9%87%8F/"/>
      <url>/2019/02/25/CFM%E4%B8%8E%E8%B4%A8%E9%87%8F%E6%B5%81%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><ul><li><p>CFM refers to the method of measuring the volume of air moving through a ventilation system or other space, also known as “Cubic Feet per Minute.”This is a standard unit of measurement found in many forms of ventilation, both in vehicle and in home heating, ventilation and air conditioning systems.<a href="https://www.reference.com/vehicles/cfm-airflow-20969775e326400d" target="_blank" rel="noopener">https://www.reference.com/vehicles/cfm-airflow-20969775e326400d</a></p></li><li><p>Cubic feet per minute (CFM) is a measure used in Industrial hygiene and ventilation engineering. It describes the rate of flow of a gas or air volume into or out of a space.A standard measurement of airflow that indicates how many cubic feet of air pass by a stationary point in one minute. The higher the number, the more air is being forced through the system. The volumetric flow rate of a liquid or gas in cubic feet per minute. 1 CFM equals approximately 0.47 liter per second. <a href="https://www.convertunits.com/info/cfm" target="_blank" rel="noopener">https://www.convertunits.com/info/cfm</a></p><h1 id="Convert-Flux-to-CFM"><a href="#Convert-Flux-to-CFM" class="headerlink" title="Convert $Flux$ to $CFM$"></a>Convert $Flux$ to $CFM$</h1><p>$1 kg / s=1 m^3 \cdot \rho/s=3.280839895^3 \cdot ft^3/s \cdot \rho= 2118.88 \cdot \rho/min$ </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux远程登陆</title>
      <link href="/2019/02/22/linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/"/>
      <url>/2019/02/22/linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<h1 id="连接远程服务器"><a href="#连接远程服务器" class="headerlink" title="连接远程服务器"></a>连接远程服务器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-client</span><br><span class="line">ssh user@192.168.1.111 -p 1234</span><br></pre></td></tr></table></figure><h1 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h1><ul><li>安装x11<br><code>sudo apt install x11-common</code></li><li>连接服务器<br><code>ssh -X user@192.168.1.111 -p 1234</code></li></ul><h1 id="本地文件夹形式访问远程服务器"><a href="#本地文件夹形式访问远程服务器" class="headerlink" title="本地文件夹形式访问远程服务器"></a>本地文件夹形式访问远程服务器</h1><a id="more"></a><p><code>sftp://$ip:$端口号</code> 例如<code>sftp://192.168.1.111:1234</code></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu常用快捷键</title>
      <link href="/2019/02/21/ubuntu%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/02/21/ubuntu%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><code>Ctrl+Shirt+T</code>打开终端<br><code>Ctrl+L</code>查看当前文件夹路径</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EI加点准则</title>
      <link href="/2019/02/20/EI%E5%8A%A0%E7%82%B9%E5%87%86%E5%88%99/"/>
      <url>/2019/02/20/EI%E5%8A%A0%E7%82%B9%E5%87%86%E5%88%99/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kriging </tag>
            
            <tag> EI加点准则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code::Blocks注释快捷键</title>
      <link href="/2018/12/05/Code-Blocks%E6%B3%A8%E9%87%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/12/05/Code-Blocks%E6%B3%A8%E9%87%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><code>Ctrl+Shirt+c</code>快速注释多行<br><code>Ctrl+Shirt+x</code>取消注释</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeblock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置visualstudio的默认环境设置</title>
      <link href="/2018/11/29/%E8%AE%BE%E7%BD%AEvisualstudio%E7%9A%84%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/11/29/%E8%AE%BE%E7%BD%AEvisualstudio%E7%9A%84%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="在工具中找到导入和导出设置："><a href="#在工具中找到导入和导出设置：" class="headerlink" title="在工具中找到导入和导出设置："></a>在工具中找到导入和导出设置：</h1><img src="/2018/11/29/设置visualstudio的默认环境设置/1.png" title="[APE1]"><h1 id="重置所有设置："><a href="#重置所有设置：" class="headerlink" title="重置所有设置："></a>重置所有设置：</h1><img src="/2018/11/29/设置visualstudio的默认环境设置/2.png" title="[APE1]"><h1 id="选择想要的开发设置："><a href="#选择想要的开发设置：" class="headerlink" title="选择想要的开发设置："></a>选择想要的开发设置：</h1><img src="/2018/11/29/设置visualstudio的默认环境设置/3.png" title="[APE1]">]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aerodynamically_Generated_Noise_From_Fluent</title>
      <link href="/2018/11/13/Aerodynamically-Generated-Noise-From-Fluent/"/>
      <url>/2018/11/13/Aerodynamically-Generated-Noise-From-Fluent/</url>
      
        <content type="html"><![CDATA[<p>The discipline of acoustics is intimately related to fluid dynamics.Many sounds that are technologically important in industrial applications are generated by and propagated in fluid flows. The phenomena associated with sounds can therefore be understood and analyzed in the general framework of fluid dynamics. (The governing equations for acoustics are indeed the same as the ones governing fluid flows.)<br>The main challenge in numerically predicting sound waves stems from the well-recognized fact that sounds have much lower energy than fluid flows, typically by several orders of magnitude. This poses a great challenge to the computation of sounds in terms of difficulty of numerically resolving sound waves, especially when one is interested in predicting sound propagation to the far field. Another challenge comes from the difficulty of predicting the very flow phenomena (for example, turbulence) in the near field that are responsible for generating sounds.</p><a id="more"></a><h1 id="Broadband-Noise-Source-Models"><a href="#Broadband-Noise-Source-Models" class="headerlink" title="Broadband Noise Source Models"></a>Broadband Noise Source Models</h1><p>In many practical applications involving turbulent flows, noise does not have any distinct tones, and the sound energy is continuously distributed over a broad range of frequencies. In those situations involving broadband noise, statistical turbulence quantities readily computable from RANS equations can be utilized, in conjunction with semi-empirical correlations and Lighthill’s acoustic analogy, to shed some light on the source of broadband noise.</p><p>ANSYS Fluent offers several such source models that enable you to quantify the local contribution (per unit surface area or volume) to the total acoustic power generated by the flow. They include the following:</p><ul><li><p>Proudman’s formula</p></li><li><p>jet noise source model</p></li><li><p>boundary layer noise source model</p></li><li><p>source terms in the linearized Euler equations</p></li><li><p>source terms in Lilley’s equation</p></li></ul><p>Considering that one would ultimately want to come up with some measures to mitigate the noise generated by the flow in question, the source models can be employed to extract useful diagnostics on the noise source to determine which portion of the flow is primarily responsible for the noise generation. Note, however, that these source models do not predict the sound at receivers.</p><p>Unlike the direct method and the FW-H integral method, the broadband noise source models do not require transient solutions to any governing fluid dynamics equations. All source models require what typical RANS models would provide, such as the mean velocity field, turbulent kinetic energy and the dissipation rate. Therefore, the use of broadband noise source models requires the least computational resources.</p><h2 id="Proudman’s-Formula"><a href="#Proudman’s-Formula" class="headerlink" title="Proudman’s Formula"></a>Proudman’s Formula</h2><p>Proudman(<code>I. Proudman. &quot;The Generation of Noise by Isotropic Turbulence&quot;. Proc. Roy. Soc. A214. 119. 1952</code>), using Lighthill’s acoustic analogy, derived a formula for acoustic power generated by isotropic turbulence without mean flow. More recently, Lilley (<code>G. M. Lilley. &quot;The radiated noise from isotropic turbulence revisited&quot;. NASA Contract Report 93-75. NASA Langley Research Center, Hampton, VA. 1993.</code>) re-derived the formula by accounting for the retarded time difference that was neglected in Proudman’s original derivation. </p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aeroacoustics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kriging代理模型</title>
      <link href="/2018/11/10/Kriging%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/11/10/Kriging%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>程序：<code>python.scikit</code>,<code>matlab.DACE</code></p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kriging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcousticSolver求解器代码阅读</title>
      <link href="/2018/11/09/AcousticSolver%E6%B1%82%E8%A7%A3%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2018/11/09/AcousticSolver%E6%B1%82%E8%A7%A3%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="EquationSystems-gt-AcousticSystem-cpp"><a href="#EquationSystems-gt-AcousticSystem-cpp" class="headerlink" title="EquationSystems-&gt;AcousticSystem.cpp"></a>EquationSystems-&gt;AcousticSystem.cpp</h1><ul><li>AcousticSystem::v_InitObject()<br>m_bfNames背景流场变量名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m_bfNames.push_back(&quot;c0sq&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;rho0&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;u0&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;v0&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;w0&quot;);</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h1 id="EquationSystems-gt-APE-cpp"><a href="#EquationSystems-gt-APE-cpp" class="headerlink" title="EquationSystems-&gt;APE.cpp"></a>EquationSystems-&gt;APE.cpp</h1><p>下面一段代码求解了APE方程的通量项，发现这里求连续方程通量是把<code>c0sq</code>直接乘进去了，而不是求完通量后再乘以<code>c0sq</code>，这意味着求解器只能求<code>c0sq</code>空间导数很小的流动。好心累。。。为什么发布的版本这里都不该，ppt里说是改了。。。<br><img src="/2018/11/09/AcousticSolver求解器代码阅读/APEequation.png" title="[APEequation]"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Return the flux vector for the APE equations.</span><br><span class="line"> *</span><br><span class="line"> * @param physfield   Fields.</span><br><span class="line"> * @param flux        Resulting flux. flux[eq][dir][pt]</span><br><span class="line"> */</span><br><span class="line">void APE::v_GetFluxVector(</span><br><span class="line">    const Array&lt;OneD, Array&lt;OneD, NekDouble&gt;&gt; &amp;physfield,</span><br><span class="line">    Array&lt;OneD, Array&lt;OneD, Array&lt;OneD, NekDouble&gt;&gt;&gt; &amp;flux)</span><br><span class="line">&#123;</span><br><span class="line">    int nq = physfield[0].num_elements();</span><br><span class="line">    Array&lt;OneD, NekDouble&gt; tmp1(nq);</span><br><span class="line">    Array&lt;OneD, NekDouble&gt; tmp2(nq);</span><br><span class="line"></span><br><span class="line">    ASSERTL1(flux[0].num_elements() == m_spacedim,</span><br><span class="line">             &quot;Dimension of flux array and velocity array do not match&quot;);</span><br><span class="line"></span><br><span class="line">    // F_&#123;adv,p&apos;,j&#125; = \bar&#123;rho&#125;  \bar&#123;c^2&#125; u&apos;_j + p&apos; \bar&#123;u&#125;_j</span><br><span class="line">    for (int j = 0; j &lt; m_spacedim; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        Vmath::Zero(nq, flux[0][j], 1);</span><br><span class="line"></span><br><span class="line">        // construct \bar&#123;rho&#125;  \bar&#123;c^2&#125; u&apos;_j</span><br><span class="line">        Vmath::Vmul(nq, m_bf[0], 1, m_bf[1], 1, tmp1, 1);</span><br><span class="line">        Vmath::Vmul(nq, tmp1, 1, physfield[j + 1], 1, tmp1, 1);</span><br><span class="line"></span><br><span class="line">        // construct p&apos; \bar&#123;u&#125;_j term</span><br><span class="line">        Vmath::Vmul(nq, physfield[0], 1, m_bf[j + 2], 1, tmp2, 1);</span><br><span class="line"></span><br><span class="line">        // add both terms</span><br><span class="line">        Vmath::Vadd(nq, tmp1, 1, tmp2, 1, flux[0][j], 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; flux.num_elements(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERTL1(flux[i].num_elements() == m_spacedim,</span><br><span class="line">                 &quot;Dimension of flux array and velocity array do not match&quot;);</span><br><span class="line"></span><br><span class="line">        // F_&#123;adv,u&apos;_i,j&#125; = (p&apos;/ \bar&#123;rho&#125; + \bar&#123;u&#125;_k u&apos;_k) \delta_&#123;ij&#125;</span><br><span class="line">        for (int j = 0; j &lt; m_spacedim; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vmath::Zero(nq, flux[i][j], 1);</span><br><span class="line"></span><br><span class="line">            if (i - 1 == j)</span><br><span class="line">            &#123;</span><br><span class="line">                // contruct p&apos;/ \bar&#123;rho&#125; term</span><br><span class="line">                Vmath::Vdiv(nq, physfield[0], 1, m_bf[1], 1, flux[i][j], 1);</span><br><span class="line"></span><br><span class="line">                // construct \bar&#123;u&#125;_k u&apos;_k term</span><br><span class="line">                Vmath::Zero(nq, tmp1, 1);</span><br><span class="line">                for (int k = 0; k &lt; m_spacedim; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    Vmath::Vvtvp(nq, physfield[k + 1], 1, m_bf[k + 2], 1, tmp1,</span><br><span class="line">                                 1, tmp1, 1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // add terms</span><br><span class="line">                Vmath::Vadd(nq, flux[i][j], 1, tmp1, 1, flux[i][j], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APE variant 4</title>
      <link href="/2018/11/07/APE-variant-4/"/>
      <url>/2018/11/07/APE-variant-4/</url>
      
        <content type="html"><![CDATA[<p><strong><em>Ewert, R. and W. Schröder, Acoustic perturbation equations based on flow decomposition via source filtering. Journal of Computational Physics, 2003. 188(2): p. 365-398.</em></strong></p><a id="more"></a><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p>It is derived by rewriting the governing flow equations such that the left-hand side is given by the APE-1 system while the right-hand source side is defined by the remaining terms. The variant of the acoustic perturbation equations demonstrated in the figure below is APE-1.<br><img src="/2018/11/07/APE-variant-4/APE1.png" title="[APE1]"><br>The purpose is to find sources qc and qm of the APE-1 system and that can be easily computed from a compressible flow simulation without solving a Poisson equation. The figure below shows the APE-4.<br><img src="/2018/11/07/APE-variant-4/APE4.png" title="[APE4]"><br>As usual whenever acoustic analogies are applied, the viscous terms in the source are assumed to be of negligible importance. Furthermore, as evidenced in Section 4.4 the non-linear and entropy terms are of minor importance considering vortex sound problems. Then, the major vortex source term is the Lambvector.</p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算状态匹配</title>
      <link href="/2018/11/06/%E8%AE%A1%E7%AE%97%E7%8A%B6%E6%80%81%E5%8C%B9%E9%85%8D/"/>
      <url>/2018/11/06/%E8%AE%A1%E7%AE%97%E7%8A%B6%E6%80%81%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>如果我们有准确的飞行高度等参数时，我们可以根据<code>大气参数查询软件.exe</code>小程序得到温度、压力等参数，但有时文献中并没有给出这些参数，这时我们需要设置参数匹配给定的马赫数和雷诺数。可以以下通过两种方式实现</p><h1 id="调整高度"><a href="#调整高度" class="headerlink" title="调整高度"></a>调整高度</h1><p>在已知模型几何参数的前提下，我们确定弦长，然后调整高度来改变温度、压强和粘性系数达到所要的雷诺数。</p><a id="more"></a><h1 id="调整模型"><a href="#调整模型" class="headerlink" title="调整模型"></a>调整模型</h1><p>假设我们现在确定某一高度，如海平面，我们将有温度、压强和粘性系数等一系列数据，通过放缩网格的方式，我们可以匹配雷诺数。<strong><em>注意：放缩网格需要调整边界层第一层高度</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFX表达式使用函数</title>
      <link href="/2018/11/06/CFX%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2018/11/06/CFX%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h1><p>在计算带旋转机械的流场时，如果直接给定转速，可能会导致计算发散。一般会选择计算没有转速或是转速很低的初场，然后再加算。可以将转速写成表达式，利用<code>if</code>判断，当时间步达到某一步数时，改变转速，避免加算，也可以利用函数。<br><img src="/2018/11/06/CFX表达式使用函数/if.png" title="[if]"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>在<code>User Function</code>中可以定义函数，例如可以实现每隔多少步更改时间步长，避免人一直在监控。<br><img src="/2018/11/06/CFX表达式使用函数/function.png" title="[function]"></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网格注意事项</title>
      <link href="/2018/11/06/%E7%BD%91%E6%A0%BC%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2018/11/06/%E7%BD%91%E6%A0%BC%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="对称面"><a href="#对称面" class="headerlink" title="对称面"></a>对称面</h1><p>网格如果存在设置对称边界条件的面，在导入网格时，确保对称面在同一平面上。<code>ICEM</code>生成的网格，因为几何或者映射的关系可能会出现不在对称面上的网格点，在导出网格时，可以使<code>Edit Mesh-&gt;Move Nodes</code>功能将网格点强制平移到对称面上。<br><img src="/2018/11/06/网格注意事项/sym.png" title="[sym]"></p><h1 id="负体积"><a href="#负体积" class="headerlink" title="负体积"></a>负体积</h1><p><code>CFX</code>和<code>ICEM</code>判断负体积的方式不太一样，从使用经验上看，<code>ICEM</code>正体积的网格导入<code>CFX</code>中计算没哟太大的问题，网格拓扑和过渡很好的网格导入CFX中纵使边界层第一层高度为<code>1e-6</code>，出现负体积的概率也较低。建议将网格边界层第一层高度适当给大到<code>1e-5</code>量级，如此能规避很多问题。如果出现负体积，将出现负体积的点坐标输入到<code>tin</code>文件中，观察该点处的网格，拉扯边界层，或者适当调整边界层高度。</p><a id="more"></a><h1 id="大马赫数"><a href="#大马赫数" class="headerlink" title="大马赫数"></a>大马赫数</h1><p>计算时流场中可能会出现大马赫数的问题，可以减小时间步长，解决该问题。如果调整时间步长不能解决问题，需要根据程序运行输出的<code>*.out</code>文件判断<code>Large Mach Number</code>出现的步数，然后重新计算，在该时间步写出<code>*.res</code>结果，观察流场，大马赫数出现的位置，继而调整网格。</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全湍和转捩计算</title>
      <link href="/2018/11/06/%E5%85%A8%E6%B9%8D%E5%92%8C%E8%BD%AC%E6%8D%A9%E8%AE%A1%E7%AE%97/"/>
      <url>/2018/11/06/%E5%85%A8%E6%B9%8D%E5%92%8C%E8%BD%AC%E6%8D%A9%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="全湍计算"><a href="#全湍计算" class="headerlink" title="全湍计算"></a>全湍计算</h1><p>主要设置在<code>Domain</code>的<code>Fluid Models</code>中，一般计算选择<code>Total Energy</code>，计算有粘流动需要勾选<code>Incl. Viscous Work Term</code>，湍流模型选择<code>Shear Stress Transport</code>。勾选<code>Transitional Turbulence-&gt;Fully Turbulent</code>，如下图所示。<br><img src="/2018/11/06/全湍和转捩计算/ft.png" title="[ft]"><br>设置完后，在<code>inlet</code>和<code>open</code>边界条件里面勾选<code>Boundary Details-&gt;Turbulence-&gt;Low</code><br><img src="/2018/11/06/全湍和转捩计算/ftin.png" title="[ftin]"></p><a id="more"></a><h1 id="转捩计算"><a href="#转捩计算" class="headerlink" title="转捩计算"></a>转捩计算</h1><p>转捩计算和全湍类似，区别在于转捩勾选<code>Transitional Turbulence-&gt;Gamma Theta Model</code>，如下图。<br><img src="/2018/11/06/全湍和转捩计算/gamma.png" title="[gamma]"><br>设置完后，在<code>inlet</code>和<code>open</code>边界条件里面勾选<code>Boundary Details-&gt;Turbulence-&gt;Intensity and Eddy Viscosity Ratio</code>，设置参数如下<br><img src="/2018/11/06/全湍和转捩计算/gammain.png" title="[gammain]"></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非定场计算设置</title>
      <link href="/2018/11/06/%E9%9D%9E%E5%AE%9A%E5%9C%BA%E8%AE%A1%E7%AE%97%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/11/06/%E9%9D%9E%E5%AE%9A%E5%9C%BA%E8%AE%A1%E7%AE%97%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="设置非定场计算参数"><a href="#设置非定场计算参数" class="headerlink" title="设置非定场计算参数"></a>设置非定场计算参数</h1><p>在<code>Analysis Type</code>中勾选<code>Transient</code>,设置物理时间<code>Total Time</code>,每步的物理时间通过<code>Timesteps</code>设置。如果加算的话，还可以设置<code>Initial Time</code>。<br><img src="/2018/11/06/非定场计算设置/basic.png" title="[basic]"></p><h1 id="设置Output-Frequency"><a href="#设置Output-Frequency" class="headerlink" title="设置Output Frequency"></a>设置Output Frequency</h1><p>因为非定场计算时间比较长，可能会有突发的意外，如果中途不保存结果，可能导致所有的计算都白费。在<code>Output Control-&gt;Trn Result</code>中新建备份结果，设置<code>Timestep Interval</code>的值，实现每隔多少步输出结果。在<code>Transient Result 1</code>中还可以勾选<code>Option-&gt;Selected Variables</code>，此时要使用备选结果进行加算需勾选<code>Include Mesh</code>。<br><img src="/2018/11/06/非定场计算设置/output.png" title="[output]"></p><a id="more"></a><h1 id="设置内迭代步数"><a href="#设置内迭代步数" class="headerlink" title="设置内迭代步数"></a>设置内迭代步数</h1><p>在<code>Solver Control-&gt;Max.Coeff.Loops</code>设置内迭代步数，一般默认值就好，如果计算太大可以适当给小。<br><img src="/2018/11/06/非定场计算设置/solver.png" title="[solver]"></p><h1 id="设置交接面"><a href="#设置交接面" class="headerlink" title="设置交接面"></a>设置交接面</h1><p>完成上述步骤，即可进行一般的非定场流场计算了。当如果计算旋转机械的非定场，还需要设置交接面，具体是将对应定场的<code>Frame Change-&gt;Frozen rotor</code>更改为<code>Transient Rotor Stator</code><br><img src="/2018/11/06/非定场计算设置/interface.png" title="[output]"></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体介质设定</title>
      <link href="/2018/11/06/%E6%B5%81%E4%BD%93%E4%BB%8B%E8%B4%A8%E8%AE%BE%E5%AE%9A/"/>
      <url>/2018/11/06/%E6%B5%81%E4%BD%93%E4%BB%8B%E8%B4%A8%E8%AE%BE%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>当使用Air at 25c介质时，全流场的密度不会发生改变，当我们涉及到增压时，最好是设置成理想气体。</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFX常用脚本</title>
      <link href="/2018/11/06/CFX%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/11/06/CFX%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5solve&quot; -batch -def example.def -ccl example.ccl   -fullname example</span><br></pre></td></tr></table></figure><h1 id="加算"><a href="#加算" class="headerlink" title="加算"></a>加算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5solve&quot; -batch -initial example.res -def example.def -ccl example.ccl   -fullname example</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="将结果插值到新网格并加算"><a href="#将结果插值到新网格并加算" class="headerlink" title="将结果插值到新网格并加算"></a>将结果插值到新网格并加算</h1><p>Interpolates the solution from the initial values file, if one is supplied (using the -initial option), onto the mesh from the CFX-Solver input file, rather than using the mesh from the initial values file. This option has been deprecated and should be replaced by the -initial-file or -continue-from-file option, as appropriate.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5solve&quot; -batch -initial example.res -def new.def -ccl new.ccl -interp-iv  -fullname new</span><br></pre></td></tr></table></figure></p><h1 id="中途换ccl"><a href="#中途换ccl" class="headerlink" title="中途换ccl"></a>中途换ccl</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5control&quot; example.dir -inject-commands example.ccl</span><br></pre></td></tr></table></figure><h1 id="运行宏文件"><a href="#运行宏文件" class="headerlink" title="运行宏文件"></a>运行宏文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5pre&quot; -batch example.pre</span><br></pre></td></tr></table></figure><h1 id="取结果"><a href="#取结果" class="headerlink" title="取结果"></a>取结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5mondata&quot; -varrule &quot;CATEGORY = USER POINT&quot; -res example.res -out example.dat</span><br></pre></td></tr></table></figure><h1 id="写结果"><a href="#写结果" class="headerlink" title="写结果"></a>写结果</h1><p>在计算路径的<code>*.dir</code>下，新建名为<code>stp</code>的空文件，将写出<code>res</code>结果，程序停止运行。新建名为<code>trn</code>的空文件，将写出备份结果，程序继续运行。</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>参考<code>// CFX-Solver Manager User&#39;s Guide // 11. Starting the CFX-Solver from the Command Line // 11.2. Command-Line Options and Keywords for cfx5solve</code></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在cfx里面转网格旋转轴的设置</title>
      <link href="/2018/11/06/%E5%9C%A8cfx%E9%87%8C%E9%9D%A2%E8%BD%AC%E7%BD%91%E6%A0%BC%E6%97%8B%E8%BD%AC%E8%BD%B4%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/11/06/%E5%9C%A8cfx%E9%87%8C%E9%9D%A2%E8%BD%AC%E7%BD%91%E6%A0%BC%E6%97%8B%E8%BD%AC%E8%BD%B4%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在icem里面做网格定义周期边界时，我们会得到旋转轴和基点。当旋转轴不是正XYZ时，在CFX里面需要给定旋转轴的两点，此时可以通过测量icem里面轴上两点的坐标得到。但icem测量得到的结果精度不够，此时可以通过看旋转周期边界设置中基点坐标来提高精度<br><img src="/2018/11/06/在cfx里面转网格旋转轴的设置/AXIAL.png" title="[AXIALpic]"></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nektar关于APE和LEE控制方程的一点疑惑</title>
      <link href="/2018/10/30/Nektar%E5%85%B3%E4%BA%8EAPE%E5%92%8CLEE%E6%8E%A7%E5%88%B6%E6%96%B9%E7%A8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91/"/>
      <url>/2018/10/30/Nektar%E5%85%B3%E4%BA%8EAPE%E5%92%8CLEE%E6%8E%A7%E5%88%B6%E6%96%B9%E7%A8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线性欧拉方程里面的c0"><a href="#线性欧拉方程里面的c0" class="headerlink" title="线性欧拉方程里面的c0"></a>线性欧拉方程里面的c0</h1><p>Nektar++中算例<code>LEE_2DVariableC_WeakDG_MODIFIED.xml</code>输入文件里面给出了c0sq<br>，但线性欧拉方程是没有C0项的，这里还是个变量，这一变量最后是怎么处理的？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;FUNCTION NAME=&quot;Baseflow&quot;&gt;</span><br><span class="line">  &lt;E VAR=&quot;c0sq&quot; VALUE=&quot;(1 + 0.25 * tanh(3*(x-5))) * 1.4 * Pinfinity / Rho0&quot;/&gt;</span><br><span class="line">  &lt;E VAR=&quot;rho0&quot; VALUE=&quot;Rho0&quot;/&gt;</span><br><span class="line">  &lt;E VAR=&quot;u0&quot;   VALUE=&quot;100&quot; /&gt;</span><br><span class="line">  &lt;E VAR=&quot;v0&quot;   VALUE=&quot;0&quot; /&gt;</span><br><span class="line">  &lt;E VAR=&quot;gamma&quot;   VALUE=&quot;1.4&quot; /&gt;</span><br><span class="line">&lt;/FUNCTION&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nektar++求解物理方程一般框架</title>
      <link href="/2018/10/29/Nektar-%E6%B1%82%E8%A7%A3%E7%89%A9%E7%90%86%E6%96%B9%E7%A8%8B%E4%B8%80%E8%88%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/10/29/Nektar-%E6%B1%82%E8%A7%A3%E7%89%A9%E7%90%86%E6%96%B9%E7%A8%8B%E4%B8%80%E8%88%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Create-session-reader"><a href="#Create-session-reader" class="headerlink" title="Create session reader"></a>Create session reader</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LibUtilities::SessionReaderSharedPtr session;</span><br><span class="line">session = LibUtilities::SessionReader::CreateInstance(argc, argv);</span><br></pre></td></tr></table></figure><h1 id="Create-MeshGraph"><a href="#Create-MeshGraph" class="headerlink" title="Create MeshGraph"></a>Create MeshGraph</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graph = SpatialDomains::MeshGraph::Read(session);</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="Create-driver"><a href="#Create-driver" class="headerlink" title="Create driver"></a>Create driver</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session-&gt;LoadSolverInfo(&quot;Driver&quot;,vDriverModule, &quot;Standard&quot;);</span><br><span class="line">drv = GetDriverFactory().CreateInstance(vDriverModule,session,graph);</span><br></pre></td></tr></table></figure><h1 id="Execute-driver"><a href="#Execute-driver" class="headerlink" title="Execute driver"></a>Execute driver</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drv-&gt;Execute();</span><br></pre></td></tr></table></figure><h1 id="Finalise-session"><a href="#Finalise-session" class="headerlink" title="Finalise session"></a>Finalise session</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session-&gt;Finalise();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将cfl3d.xyz格式网格转化为cgns并导入到CFX中出现碎面</title>
      <link href="/2018/10/18/%E5%B0%86cfl3d-xyz%E6%A0%BC%E5%BC%8F%E7%BD%91%E6%A0%BC%E8%BD%AC%E5%8C%96%E4%B8%BAcgns%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0CFX%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%A2%8E%E9%9D%A2/"/>
      <url>/2018/10/18/%E5%B0%86cfl3d-xyz%E6%A0%BC%E5%BC%8F%E7%BD%91%E6%A0%BC%E8%BD%AC%E5%8C%96%E4%B8%BAcgns%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0CFX%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%A2%8E%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>这是个悲伤的故事。。。<br>先说一下问题出现的大背景，我将ICEM导出的cfl3d.xyz格式的网格转化为cgns格式，并将cgns格式的网格导入CFX计算。为什么要转化网格，而不是直接导出CFX支持的网格呢？这是因为动网格程序读入读出的3d格式，其实一本万利的应该是为程序写个cgns输入输出的接口，懒人总是会遭报应的。。。<br>下图是cgns格式叶片网格导入CFX的结果，看似没有问题，，，我也兴冲冲的算了，然后细节决定成败。。。<br><img src="/2018/10/18/将cfl3d-xyz格式网格转化为cgns并导入到CFX中出现碎面/defwhole.png" title="[defpic]"></p><a id="more"></a><p>把边界条件都设置好后，会出现不在边界上的碎面。碎面是属于空间网格，不应该设置边界条件，然后不设置边界条件CFX会默认物面边界条件，很矛盾。下图给出了碎面出现的位置<br><img src="/2018/10/18/将cfl3d-xyz格式网格转化为cgns并导入到CFX中出现碎面/deflarge.png" title="[defpic]"><br>原以为翼尖曲率比较大，叶片扭转比较厉害导致这里网格质量差，所以出现了碎面，稍微移一移点就好了，可是并无卵用。尝试补了几刀还是没用。网格若是导成cfx5格式导入CFX是完全没有问题的。仔细分析了可能出现的原因，把目标锁定在前缘展向的edge，尝试了打断，无济于事。最后发现展向中间的一刀没有切透到两边，如下图所示。控制比较弱，将该刀透了就好。。。一上午的时间浪费了。。。<br><img src="/2018/10/18/将cfl3d-xyz格式网格转化为cgns并导入到CFX中出现碎面/grid.jpg" title="[grid]"></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员函数后面加一个冒号</title>
      <link href="/2018/10/05/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%86%92%E5%8F%B7/"/>
      <url>/2018/10/05/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%86%92%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>成员函数在定义的时候常常遇到下面的状态，对于我这个小白，完全不明白这一个冒号后面跟着这么一坨是为啥。其实，他的意图很简单，相当于初始化的作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int dim&gt;</span><br><span class="line">ConservationLaw&lt;dim&gt;::ConservationLaw (const char *input_filename)</span><br><span class="line">  :</span><br><span class="line">  mapping (),</span><br><span class="line">  fe (FE_Q&lt;dim&gt;(1), EulerEquations&lt;dim&gt;::n_components),</span><br><span class="line">  dof_handler (triangulation),</span><br><span class="line">  quadrature (2),</span><br><span class="line">  face_quadrature (2),</span><br><span class="line">  verbose_cout (std::cout, false)</span><br><span class="line">&#123;</span><br><span class="line">  ParameterHandler prm;</span><br><span class="line">  Parameters::AllParameters&lt;dim&gt;::declare_parameters (prm);</span><br><span class="line">  prm.parse_input (input_filename);</span><br><span class="line">  parameters.parse_parameters (prm);</span><br><span class="line">  verbose_cout.set_condition (parameters.output == Parameters::Solver::verbose);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中enum枚举量</title>
      <link href="/2018/10/03/C-%E4%B8%ADenum%E6%9E%9A%E4%B8%BE%E9%87%8F/"/>
      <url>/2018/10/03/C-%E4%B8%ADenum%E6%9E%9A%E4%B8%BE%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="enum枚举量"><a href="#enum枚举量" class="headerlink" title="enum枚举量"></a>enum枚举量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;</span><br></pre></td></tr></table></figure><p>上述语法<code>spectrum</code>为枚举，被称为<code>enumeration</code>，<code>red</code>被称为<code>enumerator</code>。他们为符号常量，对应着从<code>0</code>开始的数值。<br>枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型。如下代码段所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int color = blue;</span><br><span class="line">color =3 + blue;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spectrum band;</span><br><span class="line">band = spectrum(3);</span><br></pre></td></tr></table></figure></p><h2 id="设置枚举量的值"><a href="#设置枚举量的值" class="headerlink" title="设置枚举量的值"></a>设置枚举量的值</h2><p>可以使用赋值预算符显式地设置枚举量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum bits&#123;one=1, two=2, four=4, eight=8&#125;;</span><br></pre></td></tr></table></figure></p><p>指定值必须是整数。也可以显式地设置枚举量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum bigstep&#123;first, second=100, third&#125;</span><br></pre></td></tr></table></figure></p><p>可以创建多个值相同的枚举量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;zero, null=0, one, numero_uno=1&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>C++</code>早期的版本中，只能将<code>int</code>值赋给枚举量，但这种限制取消了，因此可以使用long甚至long long类型的值。</p><h2 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h2><p>通过强制转换，可以将取值范围中的任意整数值赋给枚举变量，即使这个值不是枚举值。例如，假设bits和myflag的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum bits&#123;one=1, two=2, four=4, eight=8&#125;;</span><br><span class="line">bits myflag;</span><br></pre></td></tr></table></figure></p><p>则下面的代码将是合法的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myflag = bits(6)</span><br></pre></td></tr></table></figure></p><p>取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采取与寻找上限方式相同的方式，但加上负号。</p>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 复合类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于类的学习</title>
      <link href="/2018/10/03/C-%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/03/C-%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><p>派生类继承了私有的成员，但是不能直接访问；公有成员被继承，可以通过公有函数间接访问私有成员。</p><ul><li>派生类对象存储了基类的数据程序（派生类继承了基类的实现）；</li><li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。<h3 id><a href="#" class="headerlink" title=" "></a> </h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限元中Runge-Kutta方法使用</title>
      <link href="/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E4%B8%ADRunge-Kutta%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E4%B8%ADRunge-Kutta%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
            <tag> time march method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限元软件之Nektar++</title>
      <link href="/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E8%BD%AF%E4%BB%B6%E4%B9%8BNektar/"/>
      <url>/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E8%BD%AF%E4%BB%B6%E4%B9%8BNektar/</url>
      
        <content type="html"><![CDATA[<h1 id="Nektar"><a href="#Nektar" class="headerlink" title="Nektar++"></a>Nektar++</h1><p>Nektar++ is an open-source software framework designed to support the<br>development of high-performance scalable solvers for partial differential<br>equations (PDEs) using the spectral/hp element method.</p><a id="more"></a><p>This package consists of a set of libraries (the framework) and a number of<br>pre-written PDE solvers for a selection of application domains.</p><p>The software and User Guide is available for download from<br><a href="http://www.nektar.info/" target="_blank" rel="noopener">http://www.nektar.info/</a>.</p><h2 id="User-Guide"><a href="#User-Guide" class="headerlink" title="User Guide"></a>User Guide</h2><p>Detailed information on compiling, installing and using the software is<br>available in the User Guide. This document is available as a pre-compiled PDF<br>from the downloads section of the project website.</p><h2 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h2><p>A number of tutorials are available, designed to walk the user through the<br>basics of spectral/hp element methods, through the use of individual solvers and<br>performing specific types of calculations.</p><p>The tutorials are available from <a href="http://doc.nektar.info/tutorials/latest" target="_blank" rel="noopener">http://doc.nektar.info/tutorials/latest</a>.</p><h2 id="Pre-requisites"><a href="#Pre-requisites" class="headerlink" title="Pre-requisites"></a>Pre-requisites</h2><p>Nektar++ requires the following software to be installed on the users system:</p><ul><li>CMake</li><li>BLAS/LAPACK</li></ul><p>Additional software is also required. This can either be installed system-wide<br>or it can be downloaded and compiled automatically during the build process.</p><p>For more detailed information, please see the User Guide.</p><h2 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation"></a>Compilation</h2><p>On most UNIX-based systems a default compilation can be performed using the<br>following commands from the top-level of the source tree:</p><pre><code>mkdir buildcd buildcmake ..make</code></pre><p>To alter the build configuration (for example, to enable parallel execution<br>support) we recommend using the <code>ccmake</code> command instead of <code>cmake</code>. </p><p>For more detailed operating-system specific instructions, please see the<br>User Guide.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>The default installation location is in a <code>dist</code> subdirectory of the <code>build</code><br>directory. This can be changed by setting the <code>CMAKE_INSTALL_PREFIX</code> option<br>using <code>ccmake</code>. To install the compiled libraries, solvers and header files, on<br>UNIX-based systems run:</p><pre><code>make install</code></pre>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插入图片方法</title>
      <link href="/2018/10/02/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95/"/>
      <url>/2018/10/02/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用标签插件引用图片"><a href="#1-使用标签插件引用图片" class="headerlink" title="1. 使用标签插件引用图片"></a>1. 使用标签插件引用图片</h1><h2 id="1-1-配置post-asset-folder"><a href="#1-1-配置post-asset-folder" class="headerlink" title="1.1. 配置post_asset_folder"></a>1.1. 配置<em>post_asset_folder</em></h2><p>首先在_config.yml中找到<em>post_asset_folder</em>，然后选择<em>true</em>。当新建<em>md</em>文件时将在<em>source</em>里新建与<em>title</em>名字一直的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: ture</span><br></pre></td></tr></table></figure></p><h2 id="1-2-安装hexo-asset-image"><a href="#1-2-安装hexo-asset-image" class="headerlink" title="1.2. 安装hexo-asset-image"></a>1.2. 安装<em>hexo-asset-image</em></h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p><strong><em>最新版3.1.1存在bug</em></strong><br>更改/node_modules/hexo-asset-image/index.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var cheerio = require(&apos;cheerio&apos;);</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version = String(hexo.version).split(&apos;.&apos;);</span><br><span class="line">hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123;</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">    var link = data.permalink;</span><br><span class="line">if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">   var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;</span><br><span class="line">else</span><br><span class="line">   var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;</span><br><span class="line">    var appendLink = &apos;&apos;;</span><br><span class="line">    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="line">    // if not with index.html endpos = link.lastIndexOf(&apos;.&apos;) + 1 support hexo-abbrlink</span><br><span class="line">    if(/.*\/index\.html$/.test(link)) &#123;</span><br><span class="line">      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html</span><br><span class="line">      // image in xxtitle/ will go to xxtitle/index/</span><br><span class="line">      appendLink = &apos;index/&apos;;</span><br><span class="line">      var endPos = link.lastIndexOf(&apos;/&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      var endPos = link.length-1;</span><br><span class="line">    &#125;</span><br><span class="line">    link = link.substring(beginPos, endPos) + &apos;/&apos; + appendLink;</span><br><span class="line"></span><br><span class="line">    var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;];</span><br><span class="line">    for(var i = 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&apos;img&apos;).each(function()&#123;</span><br><span class="line">if ($(this).attr(&apos;src&apos;))&#123;</span><br><span class="line">// For windows style path, we replace &apos;\&apos; to &apos;/&apos;.</span><br><span class="line">var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;);</span><br><span class="line">if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">   !/^\s*\//.test(src)) &#123;</span><br><span class="line">  // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed.</span><br><span class="line">  // In addition, to support multi-level local directory.</span><br><span class="line">  var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123;</span><br><span class="line">return elem != &apos;&apos;;</span><br><span class="line">  &#125;);</span><br><span class="line">  var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123;</span><br><span class="line">return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;;</span><br><span class="line">  &#125;);</span><br><span class="line">  if(srcArray.length &gt; 1)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(&apos;/&apos;);</span><br><span class="line">  $(this).attr(&apos;src&apos;, config.root + link + src);</span><br><span class="line">  console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">console.info&amp;&amp;console.info($(this));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="1-3-配置-config-yml中url"><a href="#1-3-配置-config-yml中url" class="headerlink" title="1.3. 配置_config.yml中url"></a>1.3. 配置_config.yml中url</h2><p>这种修改只对<code>asset_img</code>插图方式有效，采用markdown的方法，需要配置_config.yml中url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://sxong.github.io</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure></p><h2 id="1-4-引用格式"><a href="#1-4-引用格式" class="headerlink" title="1.4. 引用格式"></a>1.4. 引用格式</h2><p>将图片直接存放在source-&gt;_posts-&gt;title(之前新建的文件夹)，引用了直接调用图片名，不需要路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img build.jpg [Buildoptions] %&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-markdown方法"><a href="#2-markdown方法" class="headerlink" title="2. markdown方法"></a>2. markdown方法</h1><p>按照正常的引用格式使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](pathtothepic)</span><br></pre></td></tr></table></figure></p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h1><p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">hexo引用本地图片无法显示</a></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeblock中BLAS和LAPACK的配置</title>
      <link href="/2018/10/02/BLAS_LAPACK_codeblock/"/>
      <url>/2018/10/02/BLAS_LAPACK_codeblock/</url>
      
        <content type="html"><![CDATA[<p><strong><em>如何设置链接BLAS和LAPACK库</em></strong><br>据官网上的介绍，LAPACK库在MINGW上的链接目前采用的是动态链接的方式，需要下载指定的文件libblas.lib, liblapack.lib, libblas.dll和liblapack.dll（注意Code::Blocks默认编译32位程序，下载对应的库文件）。<br>右击项目，选择Build options，然后在Linker setting中编辑路径。</p><a id="more"></a><img src="/2018/10/02/BLAS_LAPACK_codeblock/build.jpg" title="选择Buildoptions"><p>具体设置如下：<br><img src="/2018/10/02/BLAS_LAPACK_codeblock/link.jpg" title="Linkingsettings"></p>]]></content>
      
      
      <categories>
          
          <category> 程序问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeblock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortran风扇优化代码从Intel Fortran2015迁移到GNU Fortran</title>
      <link href="/2018/10/02/Fortran/"/>
      <url>/2018/10/02/Fortran/</url>
      
        <content type="html"><![CDATA[<p><strong><em>代码迁移</em></strong><br>将利用Visual Studio13和Intel Fortran2015可编译运行的优化代码迁移到Code::Blocks和GNU Fortran平台上。期间出现的问题及解决方案如下：<br>1、    原先的优化代码利用了Intel Fortran2015中IFPORT模块的SYSTEMQQ()函数改用为SYSTEM()函数。</p><a id="more"></a><p>2、    Fortran语法中FREE FORMAT 格式下每行可以有132个字符，对超出限制的代码进行拆分，如kriging_train函数。</p><p>3、    subs_kriging.f子程序中利用了dtime和etime函数，在当前平台上函数要求变量为单精度类型，将tarry变量改成real(4)型。</p><p>4、    原先的代码利用了Intel Fortran中MKL数学库，现在将直接链接BLAS和LAPACK库。必须下载mingw32-gfortran.exe支持的库文件，在当前平台上只能实现动态链接。</p><p>5、    甲方使用的Code::Blocks17.12中MINGW5.10版本存在缺陷，语法正确的前提下，编译后的程序不能读入已经存在的文件。可以尝试升级MINGW版本，当前使用了旧版本Code::Blocks12.11，MINGW版本为4.7.1。</p><p>6、    不支持在function函数中调用Result=SYSTEM()函数，使用的SYSTEM()函数的function函数调整为subroutine子程序。</p><p>7、    原先predict_x子程序未包含变量iregress等，对变量定义进行调整，在predict_x子程序中调用Proxyparameter模块。</p><p>8、    编译后的程序在运行时会提示计算机中丢失libgfortran-3.dll等文件，将<br>该文件所在的路径(如“D:\codeblocks\MinGW\bin”)添加到环境变量中。</p><p>9、    当找不到编译器时，可以在setting—compiler—Global compiler settings中设置Toolchain executables</p>]]></content>
      
      
      <categories>
          
          <category> 程序问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
