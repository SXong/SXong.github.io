<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>boost::format使用</title>
      <link href="/2019/09/20/boost-format%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/20/boost-format%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下cmake编译时链接boost库"><a href="#Linux下cmake编译时链接boost库" class="headerlink" title="Linux下cmake编译时链接boost库"></a>Linux下cmake编译时链接boost库</h2><h1 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h1><p>find_package是CMake打包配置文件的工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(Boost</span><br><span class="line">  [version] [EXACT]      # 可选项，最小版本或者确切所需版本</span><br><span class="line">  [REQUIRED]             # 可选项，如果找不到所需库，报错</span><br><span class="line">  [COMPONENTS &lt;libs&gt;...] # 所需的库名称，比如说. &quot;date_time&quot; 代表 &quot;libboost_date_time&quot;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在上述命令成功运行完后，可以得到保存路径等信息的变量，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boost_FOUND            - 如果找到了所需的库就设为true</span><br><span class="line">Boost_INCLUDE_DIRS     - Boost头文件搜索路径</span><br><span class="line">Boost_LIBRARY_DIRS     - Boost库的链接路径</span><br><span class="line">Boost_LIBRARIES        - Boost库名，用于链接到目标程序</span><br><span class="line">Boost_VERSION          - 从boost/version.hpp文件获取的版本号</span><br><span class="line">Boost_LIB_VERSION      - 某个库的版本</span><br></pre></td></tr></table></figure></p><p>在搜索package前，可以设置变量辅助搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOST_ROOT             - 首选的Boost安装路径</span><br><span class="line">BOOST_INCLUDEDIR       - 首选的头文件搜索路径 e.g. &lt;prefix&gt;/include</span><br><span class="line">BOOST_LIBRARYDIR       - 首选的库文件搜索路径 e.g. &lt;prefix&gt;/lib</span><br><span class="line">Boost_NO_SYSTEM_PATHS  - 默认是OFF. 如果开启了，则不会搜索用户指定路径之外的路径</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># CMakeLists.txt</span><br><span class="line">project(tutorial-0)</span><br><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">set(BOOST_ROOT /usr/local/install/boost_1_61_0)</span><br><span class="line"></span><br><span class="line">find_package(Boost COMPONENTS regex system REQUIRED)</span><br><span class="line"></span><br><span class="line">if(Boost_FOUND)</span><br><span class="line">    include_directories($&#123;Boost_INCLUDE_DIRS&#125;)</span><br><span class="line">    </span><br><span class="line">    MESSAGE( STATUS &quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;)</span><br><span class="line">    MESSAGE( STATUS &quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;)</span><br><span class="line">    MESSAGE( STATUS &quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;)</span><br><span class="line"></span><br><span class="line">    add_executable(foo foo.cpp)</span><br><span class="line">    target_link_libraries (foo $&#123;Boost_LIBRARIES&#125;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p><p>通过设置BOOST_ROOT来设置首选的搜索路径<br>通过MESSAGE函数把查找的结果都打印了出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- Boost_INCLUDE_DIRS = /usr/local/install/boost_1_61_0/include.</span><br><span class="line">-- Boost_LIBRARIES = /usr/local/install/boost_1_61_0/lib/libboost_regex.so;/usr/local/install/boost_1_61_0/lib/libboost_system.so.</span><br><span class="line">-- Boost_LIB_VERSION = 1_61.</span><br></pre></td></tr></table></figure></p><p>编译过程需要用到的头文件搜索路径保存在变量Boost_INCLUDE_DIRS中，所需要link的库文件路径保存在变量Boost_LIBRARIES中</p>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>*.dll缺失</title>
      <link href="/2019/02/25/dll%E7%BC%BA%E5%A4%B1/"/>
      <url>/2019/02/25/dll%E7%BC%BA%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<p>因为安装的intel fortran或是vs的版本的差异，其他主机上编译的程序在另外的电脑运行时，常常会出现这种问题。此外，自己电脑安装多个版本软件时，也会时环境变量里的dll不是自己程序依赖的动态库，此时可以尝试找到自己程序依赖的动态库，将dll文件拷贝到程序路径下。<br>fortran可参考路经：<code>C:\Program File(x86)\Common Files\Intel\Shared Libraries\redist\intel64\compiler</code><br>** 注意64位还是32位 **</p>]]></content>
      
      
      <categories>
          
          <category> 程序问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fortran </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFM与质量流量</title>
      <link href="/2019/02/25/CFM%E4%B8%8E%E8%B4%A8%E9%87%8F%E6%B5%81%E9%87%8F/"/>
      <url>/2019/02/25/CFM%E4%B8%8E%E8%B4%A8%E9%87%8F%E6%B5%81%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><ul><li><p>CFM refers to the method of measuring the volume of air moving through a ventilation system or other space, also known as “Cubic Feet per Minute.”This is a standard unit of measurement found in many forms of ventilation, both in vehicle and in home heating, ventilation and air conditioning systems.<a href="https://www.reference.com/vehicles/cfm-airflow-20969775e326400d" target="_blank" rel="noopener">https://www.reference.com/vehicles/cfm-airflow-20969775e326400d</a></p></li><li><p>Cubic feet per minute (CFM) is a measure used in Industrial hygiene and ventilation engineering. It describes the rate of flow of a gas or air volume into or out of a space.A standard measurement of airflow that indicates how many cubic feet of air pass by a stationary point in one minute. The higher the number, the more air is being forced through the system. The volumetric flow rate of a liquid or gas in cubic feet per minute. 1 CFM equals approximately 0.47 liter per second. <a href="https://www.convertunits.com/info/cfm" target="_blank" rel="noopener">https://www.convertunits.com/info/cfm</a></p><h1 id="Convert-Flux-to-CFM"><a href="#Convert-Flux-to-CFM" class="headerlink" title="Convert $Flux$ to $CFM$"></a>Convert $Flux$ to $CFM$</h1><p>$1 kg / s=1 m^3 \cdot \rho/s=3.280839895^3 \cdot ft^3/s \cdot \rho= 2118.88 \cdot \rho/min$ </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux远程登陆</title>
      <link href="/2019/02/22/linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/"/>
      <url>/2019/02/22/linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<h1 id="连接远程服务器"><a href="#连接远程服务器" class="headerlink" title="连接远程服务器"></a>连接远程服务器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-client</span><br><span class="line">ssh user@192.168.1.111 -p 1234</span><br></pre></td></tr></table></figure><h1 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h1><ul><li>安装x11<br><code>sudo apt install x11-common</code></li><li>连接服务器<br><code>ssh -X user@192.168.1.111 -p 1234</code></li></ul><h1 id="本地文件夹形式访问远程服务器"><a href="#本地文件夹形式访问远程服务器" class="headerlink" title="本地文件夹形式访问远程服务器"></a>本地文件夹形式访问远程服务器</h1><p><code>sftp://$ip:$端口号</code> 例如<code>sftp://192.168.1.111:1234</code></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu常用快捷键</title>
      <link href="/2019/02/21/ubuntu%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/02/21/ubuntu%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><code>Ctrl+Shirt+T</code>打开终端<br><code>Ctrl+L</code>查看当前文件夹路径</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EI加点准则</title>
      <link href="/2019/02/20/EI%E5%8A%A0%E7%82%B9%E5%87%86%E5%88%99/"/>
      <url>/2019/02/20/EI%E5%8A%A0%E7%82%B9%E5%87%86%E5%88%99/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kriging </tag>
            
            <tag> EI加点准则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code::Blocks注释快捷键</title>
      <link href="/2018/12/05/Code-Blocks%E6%B3%A8%E9%87%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/12/05/Code-Blocks%E6%B3%A8%E9%87%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p><code>Ctrl+Shirt+c</code>快速注释多行<br><code>Ctrl+Shirt+x</code>取消注释</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeblock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置visualstudio的默认环境设置</title>
      <link href="/2018/11/29/%E8%AE%BE%E7%BD%AEvisualstudio%E7%9A%84%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/11/29/%E8%AE%BE%E7%BD%AEvisualstudio%E7%9A%84%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="在工具中找到导入和导出设置："><a href="#在工具中找到导入和导出设置：" class="headerlink" title="在工具中找到导入和导出设置："></a>在工具中找到导入和导出设置：</h1><h1 id="重置所有设置："><a href="#重置所有设置：" class="headerlink" title="重置所有设置："></a>重置所有设置：</h1><h1 id="选择想要的开发设置："><a href="#选择想要的开发设置：" class="headerlink" title="选择想要的开发设置："></a>选择想要的开发设置：</h1>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aerodynamically_Generated_Noise_From_Fluent</title>
      <link href="/2018/11/13/Aerodynamically-Generated-Noise-From-Fluent/"/>
      <url>/2018/11/13/Aerodynamically-Generated-Noise-From-Fluent/</url>
      
        <content type="html"><![CDATA[<p>The discipline of acoustics is intimately related to fluid dynamics.Many sounds that are technologically important in industrial applications are generated by and propagated in fluid flows. The phenomena associated with sounds can therefore be understood and analyzed in the general framework of fluid dynamics. (The governing equations for acoustics are indeed the same as the ones governing fluid flows.)<br>The main challenge in numerically predicting sound waves stems from the well-recognized fact that sounds have much lower energy than fluid flows, typically by several orders of magnitude. This poses a great challenge to the computation of sounds in terms of difficulty of numerically resolving sound waves, especially when one is interested in predicting sound propagation to the far field. Another challenge comes from the difficulty of predicting the very flow phenomena (for example, turbulence) in the near field that are responsible for generating sounds.</p><h1 id="Broadband-Noise-Source-Models"><a href="#Broadband-Noise-Source-Models" class="headerlink" title="Broadband Noise Source Models"></a>Broadband Noise Source Models</h1><p>In many practical applications involving turbulent flows, noise does not have any distinct tones, and the sound energy is continuously distributed over a broad range of frequencies. In those situations involving broadband noise, statistical turbulence quantities readily computable from RANS equations can be utilized, in conjunction with semi-empirical correlations and Lighthill’s acoustic analogy, to shed some light on the source of broadband noise.</p><p>ANSYS Fluent offers several such source models that enable you to quantify the local contribution (per unit surface area or volume) to the total acoustic power generated by the flow. They include the following:</p><ul><li><p>Proudman’s formula</p></li><li><p>jet noise source model</p></li><li><p>boundary layer noise source model</p></li><li><p>source terms in the linearized Euler equations</p></li><li><p>source terms in Lilley’s equation</p></li></ul><p>Considering that one would ultimately want to come up with some measures to mitigate the noise generated by the flow in question, the source models can be employed to extract useful diagnostics on the noise source to determine which portion of the flow is primarily responsible for the noise generation. Note, however, that these source models do not predict the sound at receivers.</p><p>Unlike the direct method and the FW-H integral method, the broadband noise source models do not require transient solutions to any governing fluid dynamics equations. All source models require what typical RANS models would provide, such as the mean velocity field, turbulent kinetic energy and the dissipation rate. Therefore, the use of broadband noise source models requires the least computational resources.</p><h2 id="Proudman’s-Formula"><a href="#Proudman’s-Formula" class="headerlink" title="Proudman’s Formula"></a>Proudman’s Formula</h2><p>Proudman(<code>I. Proudman. &quot;The Generation of Noise by Isotropic Turbulence&quot;. Proc. Roy. Soc. A214. 119. 1952</code>), using Lighthill’s acoustic analogy, derived a formula for acoustic power generated by isotropic turbulence without mean flow. More recently, Lilley (<code>G. M. Lilley. &quot;The radiated noise from isotropic turbulence revisited&quot;. NASA Contract Report 93-75. NASA Langley Research Center, Hampton, VA. 1993.</code>) re-derived the formula by accounting for the retarded time difference that was neglected in Proudman’s original derivation. </p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aeroacoustics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kriging代理模型</title>
      <link href="/2018/11/10/Kriging%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/11/10/Kriging%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>程序：<code>python.scikit</code>,<code>matlab.DACE</code></p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kriging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcousticSolver求解器代码阅读</title>
      <link href="/2018/11/09/AcousticSolver%E6%B1%82%E8%A7%A3%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2018/11/09/AcousticSolver%E6%B1%82%E8%A7%A3%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="EquationSystems-gt-AcousticSystem-cpp"><a href="#EquationSystems-gt-AcousticSystem-cpp" class="headerlink" title="EquationSystems-&gt;AcousticSystem.cpp"></a>EquationSystems-&gt;AcousticSystem.cpp</h1><ul><li>AcousticSystem::v_InitObject()<br>m_bfNames背景流场变量名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m_bfNames.push_back(&quot;c0sq&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;rho0&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;u0&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;v0&quot;);</span><br><span class="line">m_bfNames.push_back(&quot;w0&quot;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="EquationSystems-gt-APE-cpp"><a href="#EquationSystems-gt-APE-cpp" class="headerlink" title="EquationSystems-&gt;APE.cpp"></a>EquationSystems-&gt;APE.cpp</h1><p>下面一段代码求解了APE方程的通量项，发现这里求连续方程通量是把<code>c0sq</code>直接乘进去了，而不是求完通量后再乘以<code>c0sq</code>，这意味着求解器只能求<code>c0sq</code>空间导数很小的流动。好心累。。。为什么发布的版本这里都不该，ppt里说是改了。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Return the flux vector for the APE equations.</span><br><span class="line"> *</span><br><span class="line"> * @param physfield   Fields.</span><br><span class="line"> * @param flux        Resulting flux. flux[eq][dir][pt]</span><br><span class="line"> */</span><br><span class="line">void APE::v_GetFluxVector(</span><br><span class="line">    const Array&lt;OneD, Array&lt;OneD, NekDouble&gt;&gt; &amp;physfield,</span><br><span class="line">    Array&lt;OneD, Array&lt;OneD, Array&lt;OneD, NekDouble&gt;&gt;&gt; &amp;flux)</span><br><span class="line">&#123;</span><br><span class="line">    int nq = physfield[0].num_elements();</span><br><span class="line">    Array&lt;OneD, NekDouble&gt; tmp1(nq);</span><br><span class="line">    Array&lt;OneD, NekDouble&gt; tmp2(nq);</span><br><span class="line"></span><br><span class="line">    ASSERTL1(flux[0].num_elements() == m_spacedim,</span><br><span class="line">             &quot;Dimension of flux array and velocity array do not match&quot;);</span><br><span class="line"></span><br><span class="line">    // F_&#123;adv,p&apos;,j&#125; = \bar&#123;rho&#125;  \bar&#123;c^2&#125; u&apos;_j + p&apos; \bar&#123;u&#125;_j</span><br><span class="line">    for (int j = 0; j &lt; m_spacedim; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        Vmath::Zero(nq, flux[0][j], 1);</span><br><span class="line"></span><br><span class="line">        // construct \bar&#123;rho&#125;  \bar&#123;c^2&#125; u&apos;_j</span><br><span class="line">        Vmath::Vmul(nq, m_bf[0], 1, m_bf[1], 1, tmp1, 1);</span><br><span class="line">        Vmath::Vmul(nq, tmp1, 1, physfield[j + 1], 1, tmp1, 1);</span><br><span class="line"></span><br><span class="line">        // construct p&apos; \bar&#123;u&#125;_j term</span><br><span class="line">        Vmath::Vmul(nq, physfield[0], 1, m_bf[j + 2], 1, tmp2, 1);</span><br><span class="line"></span><br><span class="line">        // add both terms</span><br><span class="line">        Vmath::Vadd(nq, tmp1, 1, tmp2, 1, flux[0][j], 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; flux.num_elements(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERTL1(flux[i].num_elements() == m_spacedim,</span><br><span class="line">                 &quot;Dimension of flux array and velocity array do not match&quot;);</span><br><span class="line"></span><br><span class="line">        // F_&#123;adv,u&apos;_i,j&#125; = (p&apos;/ \bar&#123;rho&#125; + \bar&#123;u&#125;_k u&apos;_k) \delta_&#123;ij&#125;</span><br><span class="line">        for (int j = 0; j &lt; m_spacedim; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vmath::Zero(nq, flux[i][j], 1);</span><br><span class="line"></span><br><span class="line">            if (i - 1 == j)</span><br><span class="line">            &#123;</span><br><span class="line">                // contruct p&apos;/ \bar&#123;rho&#125; term</span><br><span class="line">                Vmath::Vdiv(nq, physfield[0], 1, m_bf[1], 1, flux[i][j], 1);</span><br><span class="line"></span><br><span class="line">                // construct \bar&#123;u&#125;_k u&apos;_k term</span><br><span class="line">                Vmath::Zero(nq, tmp1, 1);</span><br><span class="line">                for (int k = 0; k &lt; m_spacedim; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    Vmath::Vvtvp(nq, physfield[k + 1], 1, m_bf[k + 2], 1, tmp1,</span><br><span class="line">                                 1, tmp1, 1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // add terms</span><br><span class="line">                Vmath::Vadd(nq, flux[i][j], 1, tmp1, 1, flux[i][j], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APE variant 4</title>
      <link href="/2018/11/07/APE-variant-4/"/>
      <url>/2018/11/07/APE-variant-4/</url>
      
        <content type="html"><![CDATA[<p><strong><em>Ewert, R. and W. Schröder, Acoustic perturbation equations based on flow decomposition via source filtering. Journal of Computational Physics, 2003. 188(2): p. 365-398.</em></strong></p><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p>It is derived by rewriting the governing flow equations such that the left-hand side is given by the APE-1 system while the right-hand source side is defined by the remaining terms. The variant of the acoustic perturbation equations demonstrated in the figure below is APE-1.</p><p>The purpose is to find sources qc and qm of the APE-1 system and that can be easily computed from a compressible flow simulation without solving a Poisson equation. The figure below shows the APE-4.</p><p>As usual whenever acoustic analogies are applied, the viscous terms in the source are assumed to be of negligible importance. Furthermore, as evidenced in Section 4.4 the non-linear and entropy terms are of minor importance considering vortex sound problems. Then, the major vortex source term is the Lambvector.</p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算状态匹配</title>
      <link href="/2018/11/06/%E8%AE%A1%E7%AE%97%E7%8A%B6%E6%80%81%E5%8C%B9%E9%85%8D/"/>
      <url>/2018/11/06/%E8%AE%A1%E7%AE%97%E7%8A%B6%E6%80%81%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>如果我们有准确的飞行高度等参数时，我们可以根据<code>大气参数查询软件.exe</code>小程序得到温度、压力等参数，但有时文献中并没有给出这些参数，这时我们需要设置参数匹配给定的马赫数和雷诺数。可以以下通过两种方式实现</p><h1 id="调整高度"><a href="#调整高度" class="headerlink" title="调整高度"></a>调整高度</h1><p>在已知模型几何参数的前提下，我们确定弦长，然后调整高度来改变温度、压强和粘性系数达到所要的雷诺数。</p><h1 id="调整模型"><a href="#调整模型" class="headerlink" title="调整模型"></a>调整模型</h1><p>假设我们现在确定某一高度，如海平面，我们将有温度、压强和粘性系数等一系列数据，通过放缩网格的方式，我们可以匹配雷诺数。<strong><em>注意：放缩网格需要调整边界层第一层高度</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFX表达式使用函数</title>
      <link href="/2018/11/06/CFX%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2018/11/06/CFX%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h1><p>在计算带旋转机械的流场时，如果直接给定转速，可能会导致计算发散。一般会选择计算没有转速或是转速很低的初场，然后再加算。可以将转速写成表达式，利用<code>if</code>判断，当时间步达到某一步数时，改变转速，避免加算，也可以利用函数。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>在<code>User Function</code>中可以定义函数，例如可以实现每隔多少步更改时间步长，避免人一直在监控。</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网格注意事项</title>
      <link href="/2018/11/06/%E7%BD%91%E6%A0%BC%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2018/11/06/%E7%BD%91%E6%A0%BC%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="对称面"><a href="#对称面" class="headerlink" title="对称面"></a>对称面</h1><p>网格如果存在设置对称边界条件的面，在导入网格时，确保对称面在同一平面上。<code>ICEM</code>生成的网格，因为几何或者映射的关系可能会出现不在对称面上的网格点，在导出网格时，可以使<code>Edit Mesh-&gt;Move Nodes</code>功能将网格点强制平移到对称面上。</p><h1 id="负体积"><a href="#负体积" class="headerlink" title="负体积"></a>负体积</h1><p><code>CFX</code>和<code>ICEM</code>判断负体积的方式不太一样，从使用经验上看，<code>ICEM</code>正体积的网格导入<code>CFX</code>中计算没哟太大的问题，网格拓扑和过渡很好的网格导入CFX中纵使边界层第一层高度为<code>1e-6</code>，出现负体积的概率也较低。建议将网格边界层第一层高度适当给大到<code>1e-5</code>量级，如此能规避很多问题。如果出现负体积，将出现负体积的点坐标输入到<code>tin</code>文件中，观察该点处的网格，拉扯边界层，或者适当调整边界层高度。</p><h1 id="大马赫数"><a href="#大马赫数" class="headerlink" title="大马赫数"></a>大马赫数</h1><p>计算时流场中可能会出现大马赫数的问题，可以减小时间步长，解决该问题。如果调整时间步长不能解决问题，需要根据程序运行输出的<code>*.out</code>文件判断<code>Large Mach Number</code>出现的步数，然后重新计算，在该时间步写出<code>*.res</code>结果，观察流场，大马赫数出现的位置，继而调整网格。</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全湍和转捩计算</title>
      <link href="/2018/11/06/%E5%85%A8%E6%B9%8D%E5%92%8C%E8%BD%AC%E6%8D%A9%E8%AE%A1%E7%AE%97/"/>
      <url>/2018/11/06/%E5%85%A8%E6%B9%8D%E5%92%8C%E8%BD%AC%E6%8D%A9%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="全湍计算"><a href="#全湍计算" class="headerlink" title="全湍计算"></a>全湍计算</h1><p>主要设置在<code>Domain</code>的<code>Fluid Models</code>中，一般计算选择<code>Total Energy</code>，计算有粘流动需要勾选<code>Incl. Viscous Work Term</code>，湍流模型选择<code>Shear Stress Transport</code>。勾选<code>Transitional Turbulence-&gt;Fully Turbulent</code>，如下图所示。</p><p>设置完后，在<code>inlet</code>和<code>open</code>边界条件里面勾选<code>Boundary Details-&gt;Turbulence-&gt;Low</code></p><h1 id="转捩计算"><a href="#转捩计算" class="headerlink" title="转捩计算"></a>转捩计算</h1><p>转捩计算和全湍类似，区别在于转捩勾选<code>Transitional Turbulence-&gt;Gamma Theta Model</code>，如下图。</p><p>设置完后，在<code>inlet</code>和<code>open</code>边界条件里面勾选<code>Boundary Details-&gt;Turbulence-&gt;Intensity and Eddy Viscosity Ratio</code>，设置参数如下</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非定场计算设置</title>
      <link href="/2018/11/06/%E9%9D%9E%E5%AE%9A%E5%9C%BA%E8%AE%A1%E7%AE%97%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/11/06/%E9%9D%9E%E5%AE%9A%E5%9C%BA%E8%AE%A1%E7%AE%97%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="设置非定场计算参数"><a href="#设置非定场计算参数" class="headerlink" title="设置非定场计算参数"></a>设置非定场计算参数</h1><p>在<code>Analysis Type</code>中勾选<code>Transient</code>,设置物理时间<code>Total Time</code>,每步的物理时间通过<code>Timesteps</code>设置。如果加算的话，还可以设置<code>Initial Time</code>。</p><h1 id="设置Output-Frequency"><a href="#设置Output-Frequency" class="headerlink" title="设置Output Frequency"></a>设置Output Frequency</h1><p>因为非定场计算时间比较长，可能会有突发的意外，如果中途不保存结果，可能导致所有的计算都白费。在<code>Output Control-&gt;Trn Result</code>中新建备份结果，设置<code>Timestep Interval</code>的值，实现每隔多少步输出结果。在<code>Transient Result 1</code>中还可以勾选<code>Option-&gt;Selected Variables</code>，此时要使用备选结果进行加算需勾选<code>Include Mesh</code>。</p><h1 id="设置内迭代步数"><a href="#设置内迭代步数" class="headerlink" title="设置内迭代步数"></a>设置内迭代步数</h1><p>在<code>Solver Control-&gt;Max.Coeff.Loops</code>设置内迭代步数，一般默认值就好，如果计算太大可以适当给小。</p><h1 id="设置交接面"><a href="#设置交接面" class="headerlink" title="设置交接面"></a>设置交接面</h1><p>完成上述步骤，即可进行一般的非定场流场计算了。当如果计算旋转机械的非定场，还需要设置交接面，具体是将对应定场的<code>Frame Change-&gt;Frozen rotor</code>更改为<code>Transient Rotor Stator</code></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流体介质设定</title>
      <link href="/2018/11/06/%E6%B5%81%E4%BD%93%E4%BB%8B%E8%B4%A8%E8%AE%BE%E5%AE%9A/"/>
      <url>/2018/11/06/%E6%B5%81%E4%BD%93%E4%BB%8B%E8%B4%A8%E8%AE%BE%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>当使用Air at 25c介质时，全流场的密度不会发生改变，当我们涉及到增压时，最好是设置成理想气体。</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFX常用脚本</title>
      <link href="/2018/11/06/CFX%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/11/06/CFX%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5solve&quot; -batch -def example.def -ccl example.ccl   -fullname example</span><br></pre></td></tr></table></figure><h1 id="加算"><a href="#加算" class="headerlink" title="加算"></a>加算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5solve&quot; -batch -initial example.res -def example.def -ccl example.ccl   -fullname example</span><br></pre></td></tr></table></figure><h1 id="将结果插值到新网格并加算"><a href="#将结果插值到新网格并加算" class="headerlink" title="将结果插值到新网格并加算"></a>将结果插值到新网格并加算</h1><p>Interpolates the solution from the initial values file, if one is supplied (using the -initial option), onto the mesh from the CFX-Solver input file, rather than using the mesh from the initial values file. This option has been deprecated and should be replaced by the -initial-file or -continue-from-file option, as appropriate.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5solve&quot; -batch -initial example.res -def new.def -ccl new.ccl -interp-iv  -fullname new</span><br></pre></td></tr></table></figure><h1 id="中途换ccl"><a href="#中途换ccl" class="headerlink" title="中途换ccl"></a>中途换ccl</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5control&quot; example.dir -inject-commands example.ccl</span><br></pre></td></tr></table></figure><h1 id="运行宏文件"><a href="#运行宏文件" class="headerlink" title="运行宏文件"></a>运行宏文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5pre&quot; -batch example.pre</span><br></pre></td></tr></table></figure><h1 id="取结果"><a href="#取结果" class="headerlink" title="取结果"></a>取结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\ANSYS Inc\v140\CFX\bin\cfx5mondata&quot; -varrule &quot;CATEGORY = USER POINT&quot; -res example.res -out example.dat</span><br></pre></td></tr></table></figure><h1 id="写结果"><a href="#写结果" class="headerlink" title="写结果"></a>写结果</h1><p>在计算路径的<code>*.dir</code>下，新建名为<code>stp</code>的空文件，将写出<code>res</code>结果，程序停止运行。新建名为<code>trn</code>的空文件，将写出备份结果，程序继续运行。</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>参考<code>// CFX-Solver Manager User&#39;s Guide // 11. Starting the CFX-Solver from the Command Line // 11.2. Command-Line Options and Keywords for cfx5solve</code></p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在cfx里面转网格旋转轴的设置</title>
      <link href="/2018/11/06/%E5%9C%A8cfx%E9%87%8C%E9%9D%A2%E8%BD%AC%E7%BD%91%E6%A0%BC%E6%97%8B%E8%BD%AC%E8%BD%B4%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/11/06/%E5%9C%A8cfx%E9%87%8C%E9%9D%A2%E8%BD%AC%E7%BD%91%E6%A0%BC%E6%97%8B%E8%BD%AC%E8%BD%B4%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在icem里面做网格定义周期边界时，我们会得到旋转轴和基点。当旋转轴不是正XYZ时，在CFX里面需要给定旋转轴的两点，此时可以通过测量icem里面轴上两点的坐标得到。但icem测量得到的结果精度不够，此时可以通过看旋转周期边界设置中基点坐标来提高精度</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nektar关于APE和LEE控制方程的一点疑惑</title>
      <link href="/2018/10/30/Nektar%E5%85%B3%E4%BA%8EAPE%E5%92%8CLEE%E6%8E%A7%E5%88%B6%E6%96%B9%E7%A8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91/"/>
      <url>/2018/10/30/Nektar%E5%85%B3%E4%BA%8EAPE%E5%92%8CLEE%E6%8E%A7%E5%88%B6%E6%96%B9%E7%A8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线性欧拉方程里面的c0"><a href="#线性欧拉方程里面的c0" class="headerlink" title="线性欧拉方程里面的c0"></a>线性欧拉方程里面的c0</h1><p>Nektar++中算例<code>LEE_2DVariableC_WeakDG_MODIFIED.xml</code>输入文件里面给出了c0sq<br>，但线性欧拉方程是没有C0项的，这里还是个变量，这一变量最后是怎么处理的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;FUNCTION NAME=&quot;Baseflow&quot;&gt;</span><br><span class="line">  &lt;E VAR=&quot;c0sq&quot; VALUE=&quot;(1 + 0.25 * tanh(3*(x-5))) * 1.4 * Pinfinity / Rho0&quot;/&gt;</span><br><span class="line">  &lt;E VAR=&quot;rho0&quot; VALUE=&quot;Rho0&quot;/&gt;</span><br><span class="line">  &lt;E VAR=&quot;u0&quot;   VALUE=&quot;100&quot; /&gt;</span><br><span class="line">  &lt;E VAR=&quot;v0&quot;   VALUE=&quot;0&quot; /&gt;</span><br><span class="line">  &lt;E VAR=&quot;gamma&quot;   VALUE=&quot;1.4&quot; /&gt;</span><br><span class="line">&lt;/FUNCTION&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nektar++求解物理方程一般框架</title>
      <link href="/2018/10/29/Nektar-%E6%B1%82%E8%A7%A3%E7%89%A9%E7%90%86%E6%96%B9%E7%A8%8B%E4%B8%80%E8%88%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/10/29/Nektar-%E6%B1%82%E8%A7%A3%E7%89%A9%E7%90%86%E6%96%B9%E7%A8%8B%E4%B8%80%E8%88%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Create-session-reader"><a href="#Create-session-reader" class="headerlink" title="Create session reader"></a>Create session reader</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LibUtilities::SessionReaderSharedPtr session;</span><br><span class="line">session = LibUtilities::SessionReader::CreateInstance(argc, argv);</span><br></pre></td></tr></table></figure><h1 id="Create-MeshGraph"><a href="#Create-MeshGraph" class="headerlink" title="Create MeshGraph"></a>Create MeshGraph</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graph = SpatialDomains::MeshGraph::Read(session);</span><br></pre></td></tr></table></figure><h1 id="Create-driver"><a href="#Create-driver" class="headerlink" title="Create driver"></a>Create driver</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session-&gt;LoadSolverInfo(&quot;Driver&quot;,vDriverModule, &quot;Standard&quot;);</span><br><span class="line">drv = GetDriverFactory().CreateInstance(vDriverModule,session,graph);</span><br></pre></td></tr></table></figure><h1 id="Execute-driver"><a href="#Execute-driver" class="headerlink" title="Execute driver"></a>Execute driver</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drv-&gt;Execute();</span><br></pre></td></tr></table></figure><h1 id="Finalise-session"><a href="#Finalise-session" class="headerlink" title="Finalise session"></a>Finalise session</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session-&gt;Finalise();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将cfl3d.xyz格式网格转化为cgns并导入到CFX中出现碎面</title>
      <link href="/2018/10/18/%E5%B0%86cfl3d-xyz%E6%A0%BC%E5%BC%8F%E7%BD%91%E6%A0%BC%E8%BD%AC%E5%8C%96%E4%B8%BAcgns%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0CFX%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%A2%8E%E9%9D%A2/"/>
      <url>/2018/10/18/%E5%B0%86cfl3d-xyz%E6%A0%BC%E5%BC%8F%E7%BD%91%E6%A0%BC%E8%BD%AC%E5%8C%96%E4%B8%BAcgns%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0CFX%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%A2%8E%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>这是个悲伤的故事。。。<br>先说一下问题出现的大背景，我将ICEM导出的cfl3d.xyz格式的网格转化为cgns格式，并将cgns格式的网格导入CFX计算。为什么要转化网格，而不是直接导出CFX支持的网格呢？这是因为动网格程序读入读出的3d格式，其实一本万利的应该是为程序写个cgns输入输出的接口，懒人总是会遭报应的。。。<br>下图是cgns格式叶片网格导入CFX的结果，看似没有问题，，，我也兴冲冲的算了，然后细节决定成败。。。</p><p>把边界条件都设置好后，会出现不在边界上的碎面。碎面是属于空间网格，不应该设置边界条件，然后不设置边界条件CFX会默认物面边界条件，很矛盾。下图给出了碎面出现的位置</p><p>原以为翼尖曲率比较大，叶片扭转比较厉害导致这里网格质量差，所以出现了碎面，稍微移一移点就好了，可是并无卵用。尝试补了几刀还是没用。网格若是导成cfx5格式导入CFX是完全没有问题的。仔细分析了可能出现的原因，把目标锁定在前缘展向的edge，尝试了打断，无济于事。最后发现展向中间的一刀没有切透到两边，如下图所示。控制比较弱，将该刀透了就好。。。一上午的时间浪费了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员函数后面加一个冒号</title>
      <link href="/2018/10/05/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%86%92%E5%8F%B7/"/>
      <url>/2018/10/05/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%86%92%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>成员函数在定义的时候常常遇到下面的状态，对于我这个小白，完全不明白这一个冒号后面跟着这么一坨是为啥。其实，他的意图很简单，相当于初始化的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int dim&gt;</span><br><span class="line">ConservationLaw&lt;dim&gt;::ConservationLaw (const char *input_filename)</span><br><span class="line">  :</span><br><span class="line">  mapping (),</span><br><span class="line">  fe (FE_Q&lt;dim&gt;(1), EulerEquations&lt;dim&gt;::n_components),</span><br><span class="line">  dof_handler (triangulation),</span><br><span class="line">  quadrature (2),</span><br><span class="line">  face_quadrature (2),</span><br><span class="line">  verbose_cout (std::cout, false)</span><br><span class="line">&#123;</span><br><span class="line">  ParameterHandler prm;</span><br><span class="line">  Parameters::AllParameters&lt;dim&gt;::declare_parameters (prm);</span><br><span class="line">  prm.parse_input (input_filename);</span><br><span class="line">  parameters.parse_parameters (prm);</span><br><span class="line">  verbose_cout.set_condition (parameters.output == Parameters::Solver::verbose);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中enum枚举量</title>
      <link href="/2018/10/03/C-%E4%B8%ADenum%E6%9E%9A%E4%B8%BE%E9%87%8F/"/>
      <url>/2018/10/03/C-%E4%B8%ADenum%E6%9E%9A%E4%B8%BE%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="enum枚举量"><a href="#enum枚举量" class="headerlink" title="enum枚举量"></a>enum枚举量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;</span><br></pre></td></tr></table></figure><p>上述语法<code>spectrum</code>为枚举，被称为<code>enumeration</code>，<code>red</code>被称为<code>enumerator</code>。他们为符号常量，对应着从<code>0</code>开始的数值。<br>枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型。如下代码段所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int color = blue;</span><br><span class="line">color =3 + blue;</span><br></pre></td></tr></table></figure><p>如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spectrum band;</span><br><span class="line">band = spectrum(3);</span><br></pre></td></tr></table></figure><h2 id="设置枚举量的值"><a href="#设置枚举量的值" class="headerlink" title="设置枚举量的值"></a>设置枚举量的值</h2><p>可以使用赋值预算符显式地设置枚举量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum bits&#123;one=1, two=2, four=4, eight=8&#125;;</span><br></pre></td></tr></table></figure><p>指定值必须是整数。也可以显式地设置枚举量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum bigstep&#123;first, second=100, third&#125;</span><br></pre></td></tr></table></figure><p>可以创建多个值相同的枚举量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;zero, null=0, one, numero_uno=1&#125;</span><br></pre></td></tr></table></figure><p>在<code>C++</code>早期的版本中，只能将<code>int</code>值赋给枚举量，但这种限制取消了，因此可以使用long甚至long long类型的值。</p><h2 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h2><p>通过强制转换，可以将取值范围中的任意整数值赋给枚举变量，即使这个值不是枚举值。例如，假设bits和myflag的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum bits&#123;one=1, two=2, four=4, eight=8&#125;;</span><br><span class="line">bits myflag;</span><br></pre></td></tr></table></figure><p>则下面的代码将是合法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myflag = bits(6)</span><br></pre></td></tr></table></figure><p>取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采取与寻找上限方式相同的方式，但加上负号。</p>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 复合类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++关于类的学习</title>
      <link href="/2018/10/03/C-%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/03/C-%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><p>派生类继承了私有的成员，但是不能直接访问；公有成员被继承，可以通过公有函数间接访问私有成员。</p><ul><li>派生类对象存储了基类的数据程序（派生类继承了基类的实现）；</li><li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。<br>### </li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限元中Runge-Kutta方法使用</title>
      <link href="/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E4%B8%ADRunge-Kutta%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E4%B8%ADRunge-Kutta%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
            <tag> time march method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限元软件之Nektar++</title>
      <link href="/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E8%BD%AF%E4%BB%B6%E4%B9%8BNektar/"/>
      <url>/2018/10/03/%E6%9C%89%E9%99%90%E5%85%83%E8%BD%AF%E4%BB%B6%E4%B9%8BNektar/</url>
      
        <content type="html"><![CDATA[<h1 id="Nektar"><a href="#Nektar" class="headerlink" title="Nektar++"></a>Nektar++</h1><p>Nektar++ is an open-source software framework designed to support the<br>development of high-performance scalable solvers for partial differential<br>equations (PDEs) using the spectral/hp element method.</p><p>This package consists of a set of libraries (the framework) and a number of<br>pre-written PDE solvers for a selection of application domains.</p><p>The software and User Guide is available for download from<br><a href="http://www.nektar.info/" target="_blank" rel="noopener">http://www.nektar.info/</a>.</p><h2 id="User-Guide"><a href="#User-Guide" class="headerlink" title="User Guide"></a>User Guide</h2><p>Detailed information on compiling, installing and using the software is<br>available in the User Guide. This document is available as a pre-compiled PDF<br>from the downloads section of the project website.</p><h2 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h2><p>A number of tutorials are available, designed to walk the user through the<br>basics of spectral/hp element methods, through the use of individual solvers and<br>performing specific types of calculations.</p><p>The tutorials are available from <a href="http://doc.nektar.info/tutorials/latest" target="_blank" rel="noopener">http://doc.nektar.info/tutorials/latest</a>.</p><h2 id="Pre-requisites"><a href="#Pre-requisites" class="headerlink" title="Pre-requisites"></a>Pre-requisites</h2><p>Nektar++ requires the following software to be installed on the users system:</p><ul><li>CMake</li><li>BLAS/LAPACK</li></ul><p>Additional software is also required. This can either be installed system-wide<br>or it can be downloaded and compiled automatically during the build process.</p><p>For more detailed information, please see the User Guide.</p><h2 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation"></a>Compilation</h2><p>On most UNIX-based systems a default compilation can be performed using the<br>following commands from the top-level of the source tree:</p><pre><code>mkdir buildcd buildcmake ..make</code></pre><p>To alter the build configuration (for example, to enable parallel execution<br>support) we recommend using the <code>ccmake</code> command instead of <code>cmake</code>. </p><p>For more detailed operating-system specific instructions, please see the<br>User Guide.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>The default installation location is in a <code>dist</code> subdirectory of the <code>build</code><br>directory. This can be changed by setting the <code>CMAKE_INSTALL_PREFIX</code> option<br>using <code>ccmake</code>. To install the compiled libraries, solvers and header files, on<br>UNIX-based systems run:</p><pre><code>make install</code></pre>]]></content>
      
      
      <categories>
          
          <category> 硕士毕业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插入图片方法</title>
      <link href="/2018/10/02/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95/"/>
      <url>/2018/10/02/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="使用标签插件引用图片"><a href="#使用标签插件引用图片" class="headerlink" title="使用标签插件引用图片"></a><strong><em>使用标签插件引用图片</em></strong></h2><p>首先在_config.yml中找到<em>post_asset_folder</em>，然后选择<em>true</em>。当新建<em>md</em>文件时将在<em>source</em>里新建与<em>title</em>名字一直的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: ture</span><br></pre></td></tr></table></figure><p>将图片直接存放在source-&gt;_posts-&gt;title(之前新建的文件夹)，引用了直接调用图片民，不需要路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img build.jpg [Buildoptions] %&#125;</span><br></pre></td></tr></table></figure><h2 id="使用插件方法"><a href="#使用插件方法" class="headerlink" title="使用插件方法"></a><strong><em>使用插件方法</em></strong></h2><p>安装<em>hexo-asset-image</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>然后按照正常的引用格式使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](pathtothepic)</span><br></pre></td></tr></table></figure><h2 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a><strong><em>By the way</em></strong></h2><p>多级标题使用时#号后面要有空格</p>]]></content>
      
      
      <categories>
          
          <category> 使用帮助 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeblock中BLAS和LAPACK的配置</title>
      <link href="/2018/10/02/BLAS_LAPACK_codeblock/"/>
      <url>/2018/10/02/BLAS_LAPACK_codeblock/</url>
      
        <content type="html"><![CDATA[<p><strong><em>如何设置链接BLAS和LAPACK库</em></strong><br>据官网上的介绍，LAPACK库在MINGW上的链接目前采用的是动态链接的方式，需要下载指定的文件libblas.lib, liblapack.lib, libblas.dll和liblapack.dll（注意Code::Blocks默认编译32位程序，下载对应的库文件）。<br>右击项目，选择Build options，然后在Linker setting中编辑路径。</p><p>具体设置如下：</p>]]></content>
      
      
      <categories>
          
          <category> 程序问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeblock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortran风扇优化代码从Intel Fortran2015迁移到GNU Fortran</title>
      <link href="/2018/10/02/Fortran/"/>
      <url>/2018/10/02/Fortran/</url>
      
        <content type="html"><![CDATA[<p><strong><em>代码迁移</em></strong><br>将利用Visual Studio13和Intel Fortran2015可编译运行的优化代码迁移到Code::Blocks和GNU Fortran平台上。期间出现的问题及解决方案如下：<br>1、    原先的优化代码利用了Intel Fortran2015中IFPORT模块的SYSTEMQQ()函数改用为SYSTEM()函数。</p><p>2、    Fortran语法中FREE FORMAT 格式下每行可以有132个字符，对超出限制的代码进行拆分，如kriging_train函数。</p><p>3、    subs_kriging.f子程序中利用了dtime和etime函数，在当前平台上函数要求变量为单精度类型，将tarry变量改成real(4)型。</p><p>4、    原先的代码利用了Intel Fortran中MKL数学库，现在将直接链接BLAS和LAPACK库。必须下载mingw32-gfortran.exe支持的库文件，在当前平台上只能实现动态链接。</p><p>5、    甲方使用的Code::Blocks17.12中MINGW5.10版本存在缺陷，语法正确的前提下，编译后的程序不能读入已经存在的文件。可以尝试升级MINGW版本，当前使用了旧版本Code::Blocks12.11，MINGW版本为4.7.1。</p><p>6、    不支持在function函数中调用Result=SYSTEM()函数，使用的SYSTEM()函数的function函数调整为subroutine子程序。</p><p>7、    原先predict_x子程序未包含变量iregress等，对变量定义进行调整，在predict_x子程序中调用Proxyparameter模块。</p><p>8、    编译后的程序在运行时会提示计算机中丢失libgfortran-3.dll等文件，将<br>该文件所在的路径(如“D:\codeblocks\MinGW\bin”)添加到环境变量中。</p><p>9、    当找不到编译器时，可以在setting–compiler–Global compiler settings中设置Toolchain executables</p>]]></content>
      
      
      <categories>
          
          <category> 程序问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
